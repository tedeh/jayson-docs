<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_client_index.js.html":{"id":"lib_client_index.js.html","title":"Source: lib/client/index.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/index.js var Server = require('../server'); var utils = require('../utils'); var events = require('events'); /** * Constructor for a Jayson Client * @class Client * @extends require('events').EventEmitter * @param {Server} server An instance of Server * @param {Object} [options] * @param {Function} [options.reviver] Reviver function for JSON * @param {Function} [options.replacer] Replacer function for JSON * @param {Number} [options.version=2] JSON-RPC version to use (1|2) * @param {Function} [options.generator] Function to use for generating request IDs * @return {Client} */ var Client = function(server, options) { if(!(server instanceof Server) &amp;&amp; arguments.length === 1) { options = server; server = null; } if(!(this instanceof Client)) return new Client(server, options); var defaults = { reviver: null, replacer: null, generator: utils.generateId, version: 2 }; this.options = utils.merge(defaults, options || {}); if(server) this.server = server; }; require('util').inherits(Client, events.EventEmitter); module.exports = Client; /** * HTTP client constructor * @type ClientHttp * @static */ Client.http = require('./http'); /** * HTTPS client constructor * @type ClientHttps * @static */ Client.https = require('./https'); /** * TCP client constructor * @type ClientTcp * @static */ Client.tcp = require('./tcp'); /** * TLS client constructor * @type ClientTls * @static */ Client.tls = require('./tls'); /** * Creates a request and dispatches it if given a callback. * @param {String|Array} method A batch request if passed an Array, or a method name if passed a String * @param {Array|Object} params Parameters for the method * @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request * @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it. * @throws {TypeError} Invalid parameters * @return {Object} JSON-RPC 1.0 or 2.0 compatible request */ Client.prototype.request = function(method, params, id, callback) { var self = this; var request = null; // is this a batch request? var isBatch = Array.isArray(method) &amp;&amp; typeof(params) === 'function'; // JSON-RPC 1.0 doesn't support batching if (this.options.version === 1 &amp;&amp; isBatch) { throw new TypeError('JSON-RPC 1.0 does not support batching'); } // is this a raw request? var isRaw = !isBatch &amp;&amp; method &amp;&amp; typeof(method) === 'object' &amp;&amp; typeof(params) === 'function'; if(isBatch || isRaw) { callback = params; request = method; } else { if(typeof(id) === 'function') { callback = id; id = undefined; // specifically undefined because &quot;null&quot; is a notification request } var hasCallback = typeof(callback) === 'function'; try { request = utils.request(method, params, id, { generator: this.options.generator, version: this.options.version }); } catch(err) { if(hasCallback) return callback(err); throw err; } // no callback means we should just return a raw request if(!hasCallback) { return request; } } this.emit('request', request); this._request(request, function(err, response) { self.emit('response', request, response); self._parseResponse(err, response, callback); }); // always return the raw request return request; }; /** * Executes a request on server bound directly * @param {Object} request A JSON-RPC 1.0 or 2.0 request * @param {Function} callback Request callback that will receive the server response as the second argument * @private */ Client.prototype._request = function(request, callback) { var self = this; // serializes the request as a JSON string so that we get a copy and can run the replacer as intended utils.JSON.stringify(request, this.options, function(err, message) { if(err) throw err; self.server.call(message, function(error, success) { var response = error || success; callback(null, response); }); }); }; /** * Parses a response from a server * @param {Object} err Error to pass on that is unrelated to the actual response * @param {Object} response JSON-RPC 1.0 or 2.0 response * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters * @private */ Client.prototype._parseResponse = function(err, response, callback) { if(err) return callback(err); if(!response || typeof(response) !== 'object') { return callback(); } if(callback.length === 3) { // split callback arguments on error and response // is batch response? if(Array.isArray(response)) { // neccesary to split strictly on validity according to spec here var isError = function(res) { return typeof(res.error) !== 'undefined'; }; var isNotError = function(res) { return !isError(res); }; callback(null, response.filter(isError), response.filter(isNotError)); } else { // split regardless of validity return callback(null, response.error, response.result); } } else { return callback(null, response); } }; × Search results Close "},"lib_client_http.js.html":{"id":"lib_client_http.js.html","title":"Source: lib/client/http.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/http.js var http = require('http'); var url = require('url'); var utils = require('../utils'); var Client = require('../client'); /** * Constructor for a Jayson HTTP Client * @class ClientHttp * @constructor * @extends Client * @param {Object|String} [options] String interpreted as a URL * @param {String} [options.encoding=&quot;utf8&quot;] Encoding to use * @return {ClientHttp} */ var ClientHttp = function(options) { // accept first parameter as a url string if(typeof(options) === 'string') options = url.parse(options); if(!(this instanceof ClientHttp)) return new ClientHttp(options); Client.call(this, options); var defaults = utils.merge(this.options, { encoding: 'utf8' }); this.options = utils.merge(defaults, options || {}); }; require('util').inherits(ClientHttp, Client); module.exports = ClientHttp; ClientHttp.prototype._request = function(request, callback) { var self = this; // copies options so object can be modified in this context var options = utils.merge({}, this.options); utils.JSON.stringify(request, options, function(err, body) { if(err) return callback(err); options.method = options.method || 'POST'; var headers = { 'Content-Length': Buffer.byteLength(body, options.encoding), 'Content-Type': 'application/json; charset=utf-8', 'Accept': 'application/json' }; // let user override the headers options.headers = utils.merge(headers, options.headers || {}); var req = self._getRequestStream(options); self.emit('http request', req); req.on('response', function(res) { self.emit('http response', res, req); res.setEncoding(options.encoding); var data = ''; res.on('data', function(chunk) { data += chunk; }); res.on('end', function() { // assume we have an error if(res.statusCode &lt; 200 || res.statusCode &gt;= 300) { // assume the server gave the reason in the body var err = new Error(data); err.code = res.statusCode; callback(err); } else { // empty reply if(!data || typeof(data) !== 'string') return callback(); utils.JSON.parse(data, options, callback); } }); }); // abort on timeout req.on('timeout', function() { req.abort(); // req.abort causes &quot;error&quot; event }); // abort on error req.on('error', function(err) { self.emit('http error', err); callback(err); req.abort(); }); req.end(body); }); }; /** * Gets a stream interface to a http server * @param {Object} options An options object * @return {require('http').ClientRequest} * @private */ ClientHttp.prototype._getRequestStream = function(options) { return http.request(options || {}); }; × Search results Close "},"lib_client_https.js.html":{"id":"lib_client_https.js.html","title":"Source: lib/client/https.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/https.js var https = require('https'); var ClientHttp = require('./http'); /** * Constructor for a Jayson HTTPS Client * @class ClientHttps * @constructor * @extends ClientHttp * @param {Object|String} [options] String interpreted as a URL * @param {String} [options.encoding=&quot;utf8&quot;] Encoding to use * @return {ClientHttps} */ var ClientHttps = function(options) { if(!(this instanceof ClientHttps)) return new ClientHttps(options); // just proxy to constructor for ClientHttp ClientHttp.call(this, options); }; require('util').inherits(ClientHttps, ClientHttp); module.exports = ClientHttps; /** * Gets a stream interface to a https server * @param {Object} options An options object * @return {require('https').ClientRequest} * @private */ ClientHttps.prototype._getRequestStream = function(options) { return https.request(options || {}); }; × Search results Close "},"lib_client_tcp.js.html":{"id":"lib_client_tcp.js.html","title":"Source: lib/client/tcp.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/tcp.js var net = require('net'); var url = require('url'); var utils = require('../utils'); var Client = require('../client'); /** * Constructor for a Jayson TCP Client * @class ClientTcp * @constructor * @extends Client * @param {Object|String} [options] Optional hash of settings or a URL * @return {ClientTcp} */ var ClientTcp = function(options) { // accept first parameter as a url string if(typeof(options) === 'string') options = url.parse(options); if(!(this instanceof ClientTcp)) return new ClientTcp(options); Client.call(this, options); var defaults = utils.merge(this.options, { encoding: 'utf8' }); this.options = utils.merge(defaults, options || {}); }; require('util').inherits(ClientTcp, Client); module.exports = ClientTcp; ClientTcp.prototype._request = function(request, callback) { var self = this; // copies options so object can be modified in this context var options = utils.merge({}, this.options); utils.JSON.stringify(request, options, function(err, body) { if(err) return callback(err); var handled = false; var conn = net.connect(options, function() { conn.setEncoding(options.encoding); // wont get anything for notifications, just end here if(utils.Request.isNotification(request)) { handled = true; conn.end(body); callback(); } else { utils.parseStream(conn, options, function(err, response) { handled = true; conn.end(); if(err) return callback(err); callback(null, response); }); conn.write(body); } }); conn.on('error', function(err) { self.emit('tcp error', err); callback(err); }); conn.on('end', function() { if(!handled) callback(); }); }); }; × Search results Close "},"lib_client_tls.js.html":{"id":"lib_client_tls.js.html","title":"Source: lib/client/tls.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/tls.js var tls = require('tls'); var url = require('url'); var utils = require('../utils'); var Client = require('../client'); /** * Constructor for a Jayson TLS-encrypted TCP Client * @class ClientTls * @constructor * @extends Client * @param {Object|String} [options] Optional hash of settings or a URL * @return {ClientTls} */ var ClientTls = function(options) { // accept first parameter as a url string if(typeof(options) === 'string') options = url.parse(options); if(!(this instanceof ClientTls)) return new ClientTls(options); Client.call(this, options); var defaults = utils.merge(this.options, { encoding: 'utf8' }); this.options = utils.merge(defaults, options || {}); }; require('util').inherits(ClientTls, Client); module.exports = ClientTls; ClientTls.prototype._request = function(request, callback) { var self = this; // copies options so object can be modified in this context var options = utils.merge({}, this.options); utils.JSON.stringify(request, options, function(err, body) { if(err) return callback(err); var handled = false; var conn = tls.connect(options, function() { conn.setEncoding(options.encoding); // wont get anything for notifications, just end here if(utils.Request.isNotification(request)) { handled = true; conn.end(body); callback(); } else { utils.parseStream(conn, options, function(err, response) { handled = true; conn.end(); if(err) return callback(err); callback(null, response); }); conn.write(body); } }); conn.on('error', function(err) { self.emit('tcp error', err); callback(err); }); conn.on('end', function() { if(!handled) callback(); }); }); }; × Search results Close "},"lib_index.js.html":{"id":"lib_index.js.html","title":"Source: lib/index.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/index.js /** * Namespace available as require('jayson') * @namespace Jayson */ var Jayson = module.exports; /** * @static * @type Client */ Jayson.Client = Jayson.client = require(__dirname + '/client'); /** * @static * @type Server */ Jayson.Server = Jayson.server = require(__dirname + '/server'); /** * @static * @type Utils */ Jayson.Utils = Jayson.utils = require(__dirname + '/utils'); /** * @static * @type Method */ Jayson.Method = Jayson.method = require(__dirname + '/method'); × Search results Close "},"promise_lib_index.js.html":{"id":"promise_lib_index.js.html","title":"Source: promise/lib/index.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/index.js var Jayson = require('../..'); /** * Namespace available as require('jayson/promise') * @namespace JaysonPromise */ var JaysonPromise = module.exports; /** * @static * @type PromiseClient */ JaysonPromise.Client = JaysonPromise.client = require(__dirname + '/client'); /** * @static * @type Server */ JaysonPromise.Server = JaysonPromise.server = require(__dirname + '/server'); /** * @static * @type Utils */ JaysonPromise.Utils = JaysonPromise.utils = Jayson.utils; /** * @static * @type PromiseMethod */ JaysonPromise.Method = JaysonPromise.method = require(__dirname + '/method'); × Search results Close "},"lib_method.js.html":{"id":"lib_method.js.html","title":"Source: lib/method.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/method.js var jayson = require(__dirname); var utils = require('./utils'); var _ = require('lodash'); /** * @summary Constructor for a Jayson Method * @class Method * @param {Function} [handler] - Function to set as handler * @param {Object} [options] * @param {Function} [options.handler] - Same as separate handler * @param {Boolean} [options.collect=true] - Params to the handler are collected in one object * @param {Array|Object} [options.params] - Defines params that the handler accepts */ var Method = function(handler, options) { if(!(this instanceof Method)) { return new Method(handler, options); } // only got passed options if(_.isPlainObject(handler)) { options = handler; handler = null; } var defaults = { collect: true }; options = options || {}; this.options = utils.merge(defaults, options); this.handler = handler || options.handler; }; module.exports = Method; /** * @summary Returns the handler function associated with this method * @return {Function} */ Method.prototype.getHandler = function() { return this.handler; }; /** * @summary Sets the handler function associated with this method * @param {Function} handler */ Method.prototype.setHandler = function(handler) { this.handler = handler; }; /** * @summary Prepare parameters for the method handler * @private */ Method.prototype._getHandlerParams = function(params) { var options = this.options; var handler = this.getHandler(); var isObjectParams = !_.isArray(params) &amp;&amp; _.isObject(params) &amp;&amp; params; var isArrayParams = _.isArray(params); if(options.collect) { // collect parameters in one argument to handler switch(true) { // handler always gets an array case options.params === Array: return isArrayParams ? params : _.toArray(params); // handler always gets an object case options.params === Object: return isObjectParams ? params : _.toPlainObject(params); // handler gets a list of defined properties that should always be set case _.isArray(options.params): var undefinedParams = _.object(_.zip(options.params, _.range(options.params.length).map(_.constant(undefined)))); return _.extend(undefinedParams, _.pick(params, _.keys(params))); // handler gets a map of defined properties and their default values case _.isPlainObject(options.params): return _.extend({}, options.params, _.pick(params, _.keys(params))); // give params as is default: return params; } } else { // let the arguments pass to the handler as given if(isObjectParams) { // named parameters passed, take all parameters for handler except last (the callback) return _.initial(utils.getParameterNames(handler)).map(function(name) { return params[name]; }); } // regular parameters array passed return params; } }; /** * @summary Executes this method in the context of a server * @param {Server} server * @param {Array|Object} requestParams * @param {Function} callback */ Method.prototype.execute = function(server, requestParams, callback) { var options = this.options; var handler = this.getHandler(); var params = this._getHandlerParams(requestParams); if(options.collect) { return handler.call(server, params, callback); } // compare without the callback if(handler.length !== (params.length + 1)) { callback(server.error(jayson.Server.errors.INVALID_PARAMS)); return; } return handler.apply(server, _.flatten([params, callback])); }; × Search results Close "},"promise_lib_client_index.js.html":{"id":"promise_lib_client_index.js.html","title":"Source: promise/lib/client/index.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/index.js var promisify = require('es6-promisify'); var jayson = require('../../../'); /** * Constructor for a Jayson Promise Client * @see Client * @class PromiseClient * @extends Client * @return {PromiseClient} */ var PromiseClient = function(server, options) { if(!(this instanceof PromiseClient)) { return new PromiseClient(server, options); } jayson.Client.apply(this, arguments); this.request = promisify(this.request); }; require('util').inherits(PromiseClient, jayson.Client); /** * @type PromiseClientHttp * @static */ PromiseClient.http = require('./http'); /** * @type PromiseClientHttps * @static */ PromiseClient.https = require('./https'); /** * @type PromiseClientTls * @static */ PromiseClient.tls = require('./tls'); /** * @type PromiseClientTcp * @static */ PromiseClient.tcp = require('./tcp'); module.exports = PromiseClient; × Search results Close "},"promise_lib_client_http.js.html":{"id":"promise_lib_client_http.js.html","title":"Source: promise/lib/client/http.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/http.js var promisify = require('es6-promisify'); var jayson = require('../../../'); /** * Constructor for a Jayson Promise Client Http * @see Client * @class PromiseClientHttp * @extends ClientHttp * @return {PromiseClientHttp} */ var PromiseClientHttp = function(options) { if(!(this instanceof PromiseClientHttp)) { return new PromiseClientHttp(options); } jayson.Client.http.apply(this, arguments); this.request = promisify(this.request); }; require('util').inherits(PromiseClientHttp, jayson.Client.http); module.exports = PromiseClientHttp; × Search results Close "},"promise_lib_client_https.js.html":{"id":"promise_lib_client_https.js.html","title":"Source: promise/lib/client/https.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/https.js var promisify = require('es6-promisify'); var jayson = require('../../../'); /** * Constructor for a Jayson Promise Client Http * @see Client * @class PromiseClientHttps * @extends ClientHttps * @return {PromiseClientHttps} */ var PromiseClientHttps = function(options) { if(!(this instanceof PromiseClientHttps)) { return new PromiseClientHttps(options); } jayson.Client.https.apply(this, arguments); this.request = promisify(this.request); }; require('util').inherits(PromiseClientHttps, jayson.Client.https); module.exports = PromiseClientHttps; × Search results Close "},"promise_lib_client_tcp.js.html":{"id":"promise_lib_client_tcp.js.html","title":"Source: promise/lib/client/tcp.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/tcp.js var promisify = require('es6-promisify'); var jayson = require('../../../'); /** * Constructor for a Jayson Promise Client Tcp * @see Client * @class PromiseClientTcp * @extends ClientTcp * @return {PromiseClientTcp} */ var PromiseClientTcp = function(options) { if(!(this instanceof PromiseClientTcp)) { return new PromiseClientTcp(options); } jayson.Client.tcp.apply(this, arguments); this.request = promisify(this.request); }; require('util').inherits(PromiseClientTcp, jayson.Client.tcp); module.exports = PromiseClientTcp; × Search results Close "},"promise_lib_client_tls.js.html":{"id":"promise_lib_client_tls.js.html","title":"Source: promise/lib/client/tls.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/tls.js var promisify = require('es6-promisify'); var jayson = require('../../../'); /** * Constructor for a Jayson Promise Client Tls * @see Client * @class PromiseClientTls * @extends ClientTls * @return {PromiseClientTls} */ var PromiseClientTls = function(options) { if(!(this instanceof PromiseClientTls)) { return new PromiseClientTls(options); } jayson.Client.tls.apply(this, arguments); this.request = promisify(this.request); }; require('util').inherits(PromiseClientTls, jayson.Client.tls); module.exports = PromiseClientTls; × Search results Close "},"promise_lib_method.js.html":{"id":"promise_lib_method.js.html","title":"Source: promise/lib/method.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/method.js var jayson = require('../../'); /** * Constructor for a Jayson Promise Method * @see Method * @class PromiseMethod * @extends Method * @return {PromiseMethod} */ var PromiseMethod = module.exports = function(handler, options) { if(!(this instanceof PromiseMethod)) { return new PromiseMethod(handler, options); } jayson.Method.apply(this, arguments); }; require('util').inherits(PromiseMethod, jayson.Method); module.exports = PromiseMethod; /** * @summary Executes this method in the context of a server * @param {Server} server * @param {Array|Object} requestParams * @param {Function} outerCallback * @return {Promise} */ PromiseMethod.prototype.execute = function(server, requestParams, outerCallback) { var wasPromised = false; var promise = jayson.Method.prototype.execute.call(this, server, requestParams, function() { if(wasPromised) return; // ignore any invocations of the callback if a promise was returned outerCallback.apply(null, arguments); }); wasPromised = promise instanceof Promise; // if the handler returned a promise, call the callback when it resolves if(wasPromised) { return promise.then( function(fulfilled) { outerCallback(null, fulfilled); }, function(rejected) { outerCallback(rejected); } ); } }; × Search results Close "},"promise_lib_server.js.html":{"id":"promise_lib_server.js.html","title":"Source: promise/lib/server.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/server.js var Method = require('./method'); var jayson = require('../../'); /** * Constructor for a Jayson Promise Server * @see Server * @class PromiseServer * @extends Server * @return {PromiseServer} */ var PromiseServer = function(methods, options) { if(!(this instanceof PromiseServer)) { return new PromiseServer(methods, options); } options = options || {}; options.methodConstructor = Method; jayson.Server.call(this, methods, options); }; require('util').inherits(PromiseServer, jayson.Server); module.exports = PromiseServer; × Search results Close "},"lib_server_index.js.html":{"id":"lib_server_index.js.html","title":"Source: lib/server/index.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/index.js var jayson = require('../'); var events = require('events'); var _ = require('lodash'); var utils = require('../utils'); /** * Constructor for a Jayson Server * @class Server * @extends require('events').EventEmitter * @param {Object} [methods] Methods to add * @param {Object} [options] * @param {Boolean} [options.collect=true] Passed to Jayson.Method as an option when created * @param {Boolean} [options.params] Passed to Jayson.Method as an option when created * @param {Function} [options.reviver] Reviver function for JSON * @param {Function} [options.replacer] Replacer function for JSON * @param {Function} [options.methodConstructor] Methods will be made instances of this class * @param {String} [options.encoding=&quot;utf8&quot;] Encoding to use * @param {Number} [options.version=2] JSON-RPC version to use (1|2) * @param {Function} [options.router] Function to use for routing methods * @property {Object} options A reference to the internal options object that can be modified directly * @property {Object} errorMessages Map of error code to error message pairs that will be used in server responses * @property {ServerHttp} http HTTP interface constructor * @property {ServerHttps} https HTTPS interface constructor * @property {ServerTcp} tcp TCP interface constructor * @property {ServerTls} tls TLS interface constructor * @property {Middleware} middleware Middleware generator function * @return {Server} */ var Server = function(methods, options) { if(!(this instanceof Server)) { return new Server(methods, options); } var defaults = { reviver: null, replacer: null, encoding: 'utf8', version: 2, collect: true, methodConstructor: jayson.Method, router: function(method) { return this.getMethod(method); } }; this.options = utils.merge(defaults, options || {}); // bind router to the server this.options.router = this.options.router.bind(this); this._methods = {}; // adds methods passed to constructor this.methods(methods || {}); // assigns interfaces to this instance var interfaces = Server.interfaces; for(var name in interfaces) { this[name] = interfaces[name].bind(interfaces[name], this); } // copies error messages for defined codes into this instance this.errorMessages = {}; for(var handle in Server.errors) { var code = Server.errors[handle]; this.errorMessages[code] = Server.errorMessages[code]; } }; require('util').inherits(Server, events.EventEmitter); module.exports = Server; /** * Interfaces that will be automatically bound as properties of a Server instance * @enum {Function} * @static */ Server.interfaces = { http: require('./http'), https: require('./https'), tcp: require('./tcp'), tls: require('./tls'), middleware: require('./middleware') }; /** * JSON-RPC specification errors that map to an integer code * @enum {Number} * @static */ Server.errors = { PARSE_ERROR: -32700, INVALID_REQUEST: -32600, METHOD_NOT_FOUND: -32601, INVALID_PARAMS: -32602, INTERNAL_ERROR: -32603 }; /* * Error codes that map to an error message * @enum {String} * @static */ Server.errorMessages = {}; Server.errorMessages[Server.errors.PARSE_ERROR] = 'Parse Error'; Server.errorMessages[Server.errors.INVALID_REQUEST] = 'Invalid request'; Server.errorMessages[Server.errors.METHOD_NOT_FOUND] = 'Method not found'; Server.errorMessages[Server.errors.INVALID_PARAMS] = 'Invalid method parameter(s)'; Server.errorMessages[Server.errors.INTERNAL_ERROR] = 'Internal error'; /** * Adds a single method to the server * @param {String} name Name of method to add * @param {Function|Client} definition Function or Client for a relayed method * @throws {TypeError} Invalid parameters */ Server.prototype.method = function(name, definition) { var Method = this.options.methodConstructor; var isRelay = definition instanceof jayson.Client; var isMethod = definition instanceof Method; var isFunction = _.isFunction(definition); // a valid method is either a function or a client (relayed method) if(!isRelay &amp;&amp; !isMethod &amp;&amp; !isFunction) { throw new TypeError('method definition must be either a function, an instance of jayson.Client or an instance of jayson.Method'); } if(!name || typeof(name) !== 'string') { throw new TypeError('&quot;' + name + '&quot; must be a non-zero length string'); } if(/^rpc\\./.test(name)) { throw new TypeError('&quot;' + name + '&quot; is a reserved method name'); } // make instance of jayson.Method if(!isRelay &amp;&amp; !isMethod) { definition = new Method(definition, { collect: this.options.collect, params: this.options.params }); } this._methods[name] = definition; }; /** * Adds a batch of methods to the server * @param {Object} methods Methods to add */ Server.prototype.methods = function(methods) { methods = methods || {}; for(var name in methods) { this.method(name, methods[name]); } }; /** * Checks if a method is registered with the server * @param {String} name Name of method * @return {Boolean} */ Server.prototype.hasMethod = function(name) { return name in this._methods; }; /** * Removes a method from the server * @param {String} name */ Server.prototype.removeMethod = function(name) { if(this.hasMethod(name)) { delete this._methods[name]; } }; /** * Gets a method from the server * @param {String} name * @return {Method} */ Server.prototype.getMethod = function(name) { return this._methods[name]; }; /** * Returns a JSON-RPC compatible error property * @param {Number} [code=-32603] Error code * @param {String} [message=&quot;Internal error&quot;] Error message * @param {Object} [data] Additional data that should be provided * @return {Object} */ Server.prototype.error = function(code, message, data) { if(typeof(code) !== 'number') { code = Server.errors.INTERNAL_ERROR; } if(typeof(message) !== 'string') { message = this.errorMessages[code] || ''; } var error = { code: code, message: message }; if(typeof(data) !== 'undefined') error.data = data; return error; }; /** * Calls a method on the server * @param {Object|Array|String} request A JSON-RPC request object. Object for single request, Array for batches and String for automatic parsing (using the reviver option) * @param {Function} [callback] Callback that receives one of two arguments: first is an error and the second a response */ Server.prototype.call = function(request, originalCallback) { var self = this; if(typeof(originalCallback) !== 'function') { originalCallback = function() {}; } // compose the callback so that we may emit an event on every response var callback = function(error, response) { self.emit('response', request, response || error); originalCallback.apply(null, arguments); }; maybeParse(request, this.options, function(err, request) { var error = null; // JSON-RPC error if(err) { error = self.error(Server.errors.PARSE_ERROR, null, err); return callback(utils.response(error, undefined, undefined, self.options.version)); } // is this a batch request? if(utils.Request.isBatch(request)) { // batch requests not allowed for version 1 if(self.options.version === 1) { error = self.error(Server.errors.INVALID_REQUEST); return callback(utils.response(error, undefined, undefined, self.options.version)); } // special case if empty batch request if(!request.length) { error = self.error(Server.errors.INVALID_REQUEST); return callback(utils.response(error, undefined, undefined, self.options.version)); } return self._batch(request, callback); } self.emit('request', request); // is the request valid? if(!utils.Request.isValidRequest(request, self.options.version)) { error = self.error(Server.errors.INVALID_REQUEST); return callback(utils.response(error, undefined, undefined, self.options.version)); } // from now on we are &quot;notification-aware&quot; and can deliberately ignore errors for such requests var respond = function(error, result) { if(utils.Request.isNotification(request)) return callback(); var response = utils.response(error, result, request.id, self.options.version); if(response.error) callback(response); else callback(null, response); }; var method = self._resolveRouter(request.method, request.params); // are we attempting to invoke a relayed method? if(method instanceof jayson.Client) { return method.request(request.method, request.params, request.id, function(error, response) { if(utils.Request.isNotification(request)) return callback(); callback(error, response); }); } // does the method exist? if(!(method instanceof jayson.Method)) { return respond(self.error(Server.errors.METHOD_NOT_FOUND)); } // execute jayson.Method instance method.execute(self, request.params, function(error, result) { if(utils.Response.isValidError(error, self.options.version)) { return respond(error); } // got an invalid error if(error) { return respond(self.error(Server.errors.INTERNAL_ERROR)); } respond(null, result); }); }); }; /** * Invoke the router * @param {String} method Method to resolve * @param {Array|Object} params Request params * @return {Method} */ Server.prototype._resolveRouter = function(method, params) { var router = this.options.router; if(!_.isFunction(router)) { router = function(method) { return this.getMethod(method); }; } var resolved = router.call(this, method, params); // got a jayson.Method or a jayson.Client, return it if((resolved instanceof jayson.Method) || (resolved instanceof jayson.Client)) { return resolved; } // got a regular function, make it an instance of jayson.Method if(_.isFunction(resolved)) { return new jayson.Method(resolved); } }; /** * Evaluates a batch request * @private */ Server.prototype._batch = function(requests, callback) { var self = this; var responses = []; this.emit('batch', requests); /** * @ignore */ var maybeRespond = function() { // done when we have filled up all the responses with a truthy value var isDone = responses.every(function(response) { return response !== null; }); if(isDone) { // filters away notifications var filtered = responses.filter(function(res) { return res !== true; }); // only notifications in request means empty response if(!filtered.length) return callback(); callback(null, filtered); } }; /** * @ignore */ var wrapper = function(request, index) { responses[index] = null; return function() { if(utils.Request.isValidRequest(request, self.options.version)) { self.call(request, function(error, response) { responses[index] = error || response || true; maybeRespond(); }); } else { var error = self.error(Server.errors.INVALID_REQUEST); responses[index] = utils.response(error, undefined, undefined, self.options.version); maybeRespond(); } }; }; var stack = requests.map(function(request, index) { // ignore possibly nested requests if(utils.Request.isBatch(request)) return null; return wrapper(request, index); }); stack.forEach(function(method) { if(typeof(method) === 'function') method(); }); }; /** * Parse &quot;request&quot; if it is a string, else just invoke callback * @ignore */ function maybeParse(request, options, callback) { if(typeof(request) === 'string') { utils.JSON.parse(request, options, callback); } else { callback(null, request); } } × Search results Close "},"lib_server_http.js.html":{"id":"lib_server_http.js.html","title":"Source: lib/server/http.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/http.js var http = require('http'); var utils = require('../utils'); /** * Constructor for a Jayson HTTP server * @class ServerHttp * @extends require('http').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerHttp} */ var HttpServer = function(server, options) { if(!(this instanceof HttpServer)) return new HttpServer(server, options); this.options = utils.merge(server.options, options || {}); var listener = utils.getHttpListener(this, server); http.Server.call(this, listener); }; require('util').inherits(HttpServer, http.Server); module.exports = HttpServer; × Search results Close "},"lib_server_https.js.html":{"id":"lib_server_https.js.html","title":"Source: lib/server/https.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/https.js var https = require('https'); var utils = require('../utils'); /** * Constructor for a Jayson HTTPS server * @class ServerHttps * @extends require('https').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerHttps} */ var HttpsServer = function(server, options) { if(!(this instanceof HttpsServer)) return new HttpsServer(server, options); this.options = utils.merge(server.options, options || {}); var listener = utils.getHttpListener(this, server); https.Server.call(this, this.options, listener); }; require('util').inherits(HttpsServer, https.Server); module.exports = HttpsServer; × Search results Close "},"lib_server_middleware.js.html":{"id":"lib_server_middleware.js.html","title":"Source: lib/server/middleware.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/middleware.js var utils = require('../utils'); /** * Creates a Connect/Express compatible middleware bound to a Server * @class ServerMiddleware * @param {Server} server Server instance * @param {Object} [outerOptions] Specific options for the middleware * @return {Function} */ var Middleware = function(server, outerOptions) { return function(req, res, next) { var options = utils.merge(server.options, outerOptions || {}); // default options.end to true if(typeof(options.end) !== 'boolean') { options.end = true; } // 405 method not allowed if not POST if(!utils.isMethod(req, 'POST')) { return error(405, { 'Allow': 'POST' }); } // 415 unsupported media type if Content-Type is not correct if(!utils.isContentType(req, 'application/json')) { return error(415); } // body does not appear to be parsed, 500 server error if(!req.body || typeof(req.body) !== 'object') { return next(new Error('Request body must be parsed')); } server.call(req.body, function(error, success) { var response = error || success; utils.JSON.stringify(response, options, function(err, body) { if(err) return next(err); // empty response? if(body) { var headers = { 'content-length': Buffer.byteLength(body, options.encoding), 'content-type': 'application/json; charset=utf-8' }; res.writeHead(200, headers); res.write(body); } else { res.writeHead(204); } // if end is false, next request instead of ending it if(options.end) { res.end(); } else { next(); } }); }); // ends the request with an error code function error(code, headers) { res.writeHead(code, headers || {}); res.end(); } }; }; module.exports = Middleware; × Search results Close "},"lib_server_tcp.js.html":{"id":"lib_server_tcp.js.html","title":"Source: lib/server/tcp.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/tcp.js var net = require('net'); var utils = require('../utils'); /** * Constructor for a Jayson TCP server * @class ServerTcp * @extends require('net').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerTcp} */ var TcpServer = function(server, options) { if(!(this instanceof TcpServer)) return new TcpServer(server, options); this.options = utils.merge(server.options, options || {}); net.Server.call(this, getTcpListener(this, server)); }; require('util').inherits(TcpServer, net.Server); module.exports = TcpServer; /** * Returns a TCP connection listener bound to the server in the argument. * @param {Server} server Instance of JaysonServer * @param {net.Server} self Instance of net.Server * @return {Function} * @private * @ignore */ function getTcpListener(self, server) { return function(conn) { var options = self.options || {}; utils.parseStream(conn, options, function(err, request) { if(err) return respondError(err); server.call(request, function(error, success) { var response = error || success; if(response) { utils.JSON.stringify(response, options, function(err, body) { if(err) return respondError(err); conn.write(body); }); } else { // no response received at all, must be a notification } }); }); // ends the request with an error code function respondError(err) { var Server = require(__dirname + '/../server'); var error = server.error(Server.errors.PARSE_ERROR, null, String(err)); var response = utils.response(error, undefined, undefined, self.options.version); utils.JSON.stringify(response, options, function(err, body) { if(err) body = ''; // we tried our best. conn.end(body); }); } }; } × Search results Close "},"lib_server_tls.js.html":{"id":"lib_server_tls.js.html","title":"Source: lib/server/tls.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/tls.js var tls = require('tls'); var utils = require('../utils'); /** * Constructor for a Jayson TLS-encrypted TCP server * @class ServerTls * @extends require('tls').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerTls} */ var TlsServer = function(server, options) { if(!(this instanceof TlsServer)) return new TlsServer(server, options); this.options = utils.merge(server.options, options || {}); tls.Server.call(this, this.options, getTlsListener(this, server)); }; require('util').inherits(TlsServer, tls.Server); module.exports = TlsServer; /** * Returns a TLS-encrypted TCP connection listener bound to the server in the argument. * @param {Server} server Instance of JaysonServer * @param {tls.Server} self Instance of tls.Server * @return {Function} * @private * @ignore */ function getTlsListener(self, server) { return function(conn) { var options = self.options || {}; utils.parseStream(conn, options, function(err, request) { if(err) return respondError(err); server.call(request, function(error, success) { var response = error || success; if(response) { utils.JSON.stringify(response, options, function(err, body) { if(err) return respondError(err); conn.write(body); }); } else { // no response received at all, must be a notification } }); }); // ends the request with an error code function respondError(err) { var Server = require(__dirname + '/../server'); var error = server.error(Server.errors.PARSE_ERROR, null, String(err)); var response = utils.response(error, undefined, undefined, self.options.version); utils.JSON.stringify(response, options, function(err, body) { if(err) body = ''; // we tried our best. conn.end(body); }); } }; } × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/utils.js var _ = require('lodash'); var JSONStream = require('JSONStream'); var JSONstringify = require('json-stringify-safe'); /** * @namespace */ var Utils = module.exports; // same reference as other files use, for tidyness var utils = Utils; /** * Generates a JSON-RPC 1.0 or 2.0 request * @param {String} method Name of method to call * @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value * @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation * @param {Object} [options] * @param {Number} [options.version=2] - JSON-RPC version to use (1 or 2) * @param {Function} [options.generator] - Function that is passed the request, and the options object and is expected to return a request ID * @throws {TypeError} If any of the parameters are invalid * @return {Object} A JSON-RPC 1.0 or 2.0 request */ Utils.request = function(method, params, id, options) { if(typeof(method) !== 'string') { throw new TypeError(method + ' must be a string'); } options = options || {}; var request = { method: method }; // assume that we are doing a 2.0 request unless specified differently if(typeof(options.version) === 'undefined' || options.version !== 1) { request.jsonrpc = '2.0'; } if(params) { // params given, but invalid? if(typeof(params) !== 'object' &amp;&amp; !Array.isArray(params)) { throw new TypeError(params + ' must be an object, array or omitted'); } request.params = params; } // if id was left out, generate one (null means explicit notification) if(typeof(id) === 'undefined') { var generator = typeof(options.generator) === 'function' ? options.generator : Utils.generateId; request.id = generator(request, options); } else { request.id = id; } return request; }; /** * Generates a JSON-RPC 1.0 or 2.0 response * @param {Object} error Error member * @param {Object} result Result member * @param {String|Number|null} id Id of request * @param {Number} version JSON-RPC version to use * @return {Object} A JSON-RPC 1.0 or 2.0 response */ Utils.response = function(error, result, id, version) { id = typeof(id) === 'undefined' || id === null ? null : id; error = typeof(error) === 'undefined' || error === null ? null : error; version = typeof(version) === 'undefined' || version === null ? 2 : version; var response = (version === 2) ? { jsonrpc: &quot;2.0&quot;, id: id } : { id: id }; // errors are always included in version 1 if(version === 1) response.error = error; // one or the other with precedence for errors if(error) response.error = error; else response.result = result; return response; }; /** * Generates a random UUID * @return {String} */ Utils.generateId = function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random()*16|0, v = c == 'x' ? r : (r&amp;0x3|0x8); return v.toString(16); }); }; /** * Merges properties of object b into object a * @param {...Object} Objects to be merged * @return {Object} * @private */ Utils.merge = function() { return _.extend.apply(null, arguments); }; /** * Parses an incoming stream for requests using JSONStream * @param {Stream} stream * @param {Object} options * @param {Function} onRequest - Called once for stream errors and an unlimited amount of times for valid requests */ Utils.parseStream = function(stream, options, onRequest) { var onError = _.once(onRequest); var onSuccess = _.partial(onRequest, null); var result = JSONStream.parse(); result.on('data', function(data) { // apply reviver walk function to prevent stringify/parse again if(_.isFunction(options.reviver)) { data = Utils.walk({'': data}, '', options.reviver); } onSuccess(data); }); result.on('error', onError); stream.on('error', onError); stream.pipe(result); }; /** * Helper to parse a stream and interpret it as JSON * @param {Stream} stream Stream instance * @param {Function} [reviver] Optional reviver for JSON.parse * @param {Function} callback */ Utils.parseBody = function(stream, options, callback) { callback = _.once(callback); var data = ''; stream.setEncoding('utf8'); stream.on('data', function(str) { data += str; }); stream.on('error', function(err) { callback(err); }); stream.on('end', function() { utils.JSON.parse(data, options, function(err, request) { if(err) return callback(err); callback(null, request); }); }); }; /** * Returns a HTTP request listener bound to the server in the argument. * @param {http.Server} self Instance of a HTTP server * @param {JaysonServer} server Instance of JaysonServer (typically jayson.Server) * @return {Function} * @private */ Utils.getHttpListener = function(self, server) { return function(req, res) { var options = self.options || {}; server.emit('http request', req); // 405 method not allowed if not POST if(!Utils.isMethod(req, 'POST')) { return respond('Method Not Allowed', 405, {'allow': 'POST'}); } // 415 unsupported media type if Content-Type is not correct if(!Utils.isContentType(req, 'application/json')) { return respond('Unsupported Media Type', 415); } Utils.parseBody(req, options, function(err, request) { if(err) return respond(err, 500); server.call(request, function(error, success) { var response = error || success; if(!response) { // no response received at all, must be a notification return respond('', 204); } utils.JSON.stringify(response, options, function(err, body) { if(err) return respond(err, 500); var headers = { 'content-length': Buffer.byteLength(body, options.encoding), 'content-type': 'application/json; charset=utf-8' }; respond(body, 200, headers); }); }); }); function respond(body, code, headers) { server.emit('http response', res, req); res.writeHead(code, headers || {}); res.end(body); } }; }; /** * Determines if a HTTP Request comes with a specific Content-Type * @param {ServerRequest} request * @param {String} type * @return {Boolean} * @private */ Utils.isContentType = function(request, type) { request = request || {headers: {}}; var contentType = request.headers['content-type'] || ''; return RegExp(type, 'i').test(contentType); }; /** * Determines if a HTTP Request is of a specific method * @param {ServerRequest} request * @param {String} method * @return {Boolean} * @private */ Utils.isMethod = function(request, method) { method = (method || '').toUpperCase(); return (request.method || '') === method; }; /** * Determines the parameter names of a function * @param {Function} func * @return {Array} * @private */ Utils.getParameterNames = function(func) { if(typeof(func) !== 'function') return []; var body = func.toString(); var args = /^function .*?\\((.+?)\\)/.exec(body); if(!args) return []; var list = (args.pop() || '').split(','); return list.map(function(arg) { return arg.trim(); }); }; /** * @namespace */ Utils.JSON = {}; /** * Parses a JSON string and then invokes the given callback * @param {String} str The string to parse * @param {Object} options Object with options, possibly holding a &quot;reviver&quot; function */ Utils.JSON.parse = function(str, options, callback) { var reviver = null; var obj = null; options = options || {}; if(_.isFunction(options.reviver)) { reviver = options.reviver; } try { obj = JSON.parse.apply(JSON, _.compact([str, reviver])); } catch(err) { return callback(err); } callback(null, obj); }; /** * Stringifies JSON and then invokes the given callback * @param {Object} obj The object to stringify * @param {Object} options Object with options, possibly holding a &quot;replacer&quot; function */ Utils.JSON.stringify = function(obj, options, callback) { var replacer = null; var str = null; options = options || {}; if(_.isFunction(options.replacer)) { replacer = options.replacer; } try { str = JSONstringify.apply(JSON, _.compact([obj, replacer])); } catch(err) { return callback(err); } callback(null, str); }; /** * Recursively walk an object and apply a function on its members * @param {Object} holder The object to walk * @param {String} key The key to look at * @param {Function} fn The function to apply to members * @return {Object} */ Utils.walk = function(holder, key, fn) { var k, v, value = holder[key]; if (value &amp;&amp; typeof value === 'object') { for (k in value) { if (Object.prototype.hasOwnProperty.call(value, k)) { v = Utils.walk(value, k, fn); if (v !== undefined) { value[k] = v; } else { delete value[k]; } } } } return fn.call(holder, key, value); }; /** * @namespace */ Utils.Request = {}; /** * Determines if the passed request is a batch request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isBatch = function(request) { return Array.isArray(request); }; /** * Determines if the passed request is a notification request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isNotification = function(request) { return Boolean( request &amp;&amp; !Utils.Request.isBatch(request) &amp;&amp; (typeof(request.id) === 'undefined' || request.id === null) ); }; /** * Determines if the passed request is a valid JSON-RPC 2.0 Request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isValidVersionTwoRequest = function(request) { return Boolean( request &amp;&amp; typeof(request) === 'object' &amp;&amp; request.jsonrpc === '2.0' &amp;&amp; typeof(request.method) === 'string' &amp;&amp; ( typeof(request.params) === 'undefined' || Array.isArray(request.params) || (request.params &amp;&amp; typeof(request.params) === 'object') ) &amp;&amp; ( typeof(request.id) === 'undefined' || typeof(request.id) === 'string' || typeof(request.id) === 'number' || request.id === null ) ); }; /** * Determines if the passed request is a valid JSON-RPC 1.0 Request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isValidVersionOneRequest = function(request) { return Boolean( request &amp;&amp; typeof(request) === 'object' &amp;&amp; typeof(request.method) === 'string' &amp;&amp; Array.isArray(request.params) &amp;&amp; typeof(request.id) !== 'undefined' ); }; /** * Determines if the passed request is a valid JSON-RPC Request * @param {Object} request The request * @param {Number} version JSON-RPC version 1 or 2 * @return {Boolean} */ Utils.Request.isValidRequest = function(request, version) { version = version === 1 ? 1 : 2; return Boolean( request &amp;&amp; ( (version === 1 &amp;&amp; Utils.Request.isValidVersionOneRequest(request)) || (version === 2 &amp;&amp; Utils.Request.isValidVersionTwoRequest(request)) ) ); }; /** * @namespace */ Utils.Response = {}; /** * Determines if the passed error is a valid JSON-RPC error response * @param {Object} error The error * @param {Number} version JSON-RPC version 1 or 2 * @return {Boolean} */ Utils.Response.isValidError = function(error, version) { version = version === 1 ? 1 : 2; return Boolean( version === 1 &amp;&amp; ( typeof(error) !== 'undefined' &amp;&amp; error !== null ) || version === 2 &amp;&amp; ( error &amp;&amp; typeof(error.code) === 'number' &amp;&amp; parseInt(error.code) == error.code &amp;&amp; typeof(error.message) === 'string' ) ); }; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Classes Classes Client ClientHttp ClientHttps ClientTcp ClientTls Method Constructor for a Jayson Method PromiseClient PromiseClientHttp PromiseClientHttps PromiseClientTcp PromiseClientTls PromiseMethod PromiseServer Server ServerHttp ServerHttps ServerMiddleware ServerTcp ServerTls Namespaces Jayson JaysonPromise Utils JSON Request Response × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespaces Classes Client ClientHttp ClientHttps ClientTcp ClientTls Method Constructor for a Jayson Method PromiseClient PromiseClientHttp PromiseClientHttps PromiseClientTcp PromiseClientTls PromiseMethod PromiseServer Server ServerHttp ServerHttps ServerMiddleware ServerTcp ServerTls Namespaces Jayson JaysonPromise Utils JSON Request Response × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls jayson 2.0.0 JaysonJayson is a JSON-RPC 2.0 and 1.0 compliant server and client written in JavaScript for node.js that aims to be as simple as possible to use. Table of contents Features Example Installation Changelog Requirements Class Documentation Running tests Usage Client Interface description Notifications Batches Callback syntactic sugar Events Server Interface description Many interfaces at the same time Using the server as a relay Method routing Method definition Events Errors CORS Revivers and replacers Named parameters Promises Contributing Features Servers that can listen to several interfaces at the same time Supports both HTTP and TCP client and server connections Server-side method routing Relaying of requests to other servers JSON reviving and replacing for transparent serialization of complex objects CLI client Promises Fully tested to comply with the official JSON-RPC 2.0 specification Also supports JSON-RPC 1.0 ExampleA basic JSON-RPC 2.0 server via HTTP: Server example in examples/simple_example/server.js: var jayson = require(__dirname + '/../..'); // create a server var server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); server.http().listen(3000);Client example in examples/simple_example/client.js invoking add on the above server: var jayson = require(__dirname + '/../..'); // create a client var client = jayson.client.http({ port: 3000 }); // invoke &quot;add&quot; client.request('add', [1, 1], function(err, response) { if(err) throw err; console.log(response.result); // 2 });InstallationInstall the latest version of jayson from npm by executing npm install jayson in your shell. Do a global install with npm install --global jayson if you want the jayson client CLI in your PATH. Changelog (only notable milestones) 2.0.0 Added support for promises Breaking: collect: true is now the default option for a new jayson.Server and jayson.Method 1.2.0 Greatly improved server method definition 1.1.1 More http server events Remove fork server and client Add server routing 1.0.11 Add support for a HTTPS client 1.0.9 Add support for TCP servers and clients CLI clientThere is a CLI client in bin/jayson.js and it should be available as jayson in your shell if you installed the package with the --global switch. Run jayson --help to see how it works. RequirementsJayson does not have any special dependencies that cannot be resolved with a simple npm install. It is being continuously tested using travis-ci on the following versions: node.js 0.10 node.js 0.12 iojs Class documentationIn addition to this document, a comprehensive class documentation made with jsdoc is available at jayson.tedeh.net. Running tests Change directory to the repository root Install the development packages by executing npm install --dev Run the tests with make test UsageClientThe client is available as the Client or client property of require('jayson'). Client interface description Name Description Client Base class Client.tcp TCP interface Client.tls TLS interface Client.http HTTP interface Client.https HTTPS interface Every client supports these options: Option Default Type Description reviver undefined Function JSON.parse reviver replacer undefined Function JSON.stringify replacer generator RFC4122 generator Function Generates a String for request ID. version 2 Number JSON-RPC version to support (1 or 2) Client.httpUses the same options as http.request in addition to these options: Option Default Type Description encoding utf8 String Determines the encoding to use Client.http EventsThe HTTP server will emit the following events: Event When Arguments Notes http request Created an HTTP request 1. Instance of http.ClientRequest http response Received an HTTP response 1. Instance of http.IncomingMessage 2. Instance of http.ClientRequest http error Underlying stream emits error 1. Error http timeout Underlying stream emits timeout Automatically causes the request to abort It is possible to pass a string URL as the first argument. The URL will be run through url.parse. Example: var jayson = require('jayson'); var client = jayson.client.http('http://localhost:3000'); // client.options is now the result of url.parseClient.httpsUses the same options as https.request in addition to the same options as Client.http. This means it is also possible to pass a string URL as the first argument and have it interpreted by url.parse. Will emit the same custom events as Client.http. Client.tcpUses the same options as the base class. Client.tlsUses the same options as tls.connect. NotificationsNotification requests are for cases where the reply from the server is not important and should be ignored. This is accomplished by setting the id property of a request object to null. Client example in examples/notifications/client.js doing a notification request: var jayson = require(__dirname + '/../..'); var client = jayson.client.http({ port: 3000 }); // the third parameter is set to &quot;null&quot; to indicate a notification client.request('ping', [], null, function(err) { if(err) throw err; console.log('ok'); // request was received successfully });Server example in examples/notifications/server.js: var jayson = require(__dirname + '/../..'); var server = jayson.server({ ping: function(args, callback) { // do something, do nothing callback(); } }); server.http().listen(3000);Notes Any value that the server returns will be discarded when doing a notification request. Omitting the third argument null to Client.prototype.request does not generate a notification request. This argument has to be set explicitly to null for this to happen. Network errors and the like will still reach the callback. When the callback is invoked (with or without error) one can be certain that the server has received the request. See the Official JSON-RPC 2.0 Specification for additional information on how Jayson handles notifications that are erroneous. BatchesA batch request is an array of individual requests that are sent to the server as one. Doing a batch request is very simple in Jayson and consists of constructing an array of individual requests (created by not passing a callback to Client.prototype.request) that is then itself passed to Client.prototype.request. Combined server/client example in examples/batch_request/index.js: var jayson = require(__dirname + '/../..'); var server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); var client = jayson.client(server); var batch = [ client.request('does_not_exist', [10, 5]), client.request('add', [1, 1]), client.request('add', [0, 0], null) // a notification ]; client.request(batch, function(err, errors, successes) { if(err) throw err; console.log('errors', errors); // array of requests that errored console.log('successes', successes); // array of requests that succeeded }); client.request(batch, function(err, responses) { if(err) throw err; console.log('responses', responses); // all responses together });Notes See the Official JSON-RPC 2.0 Specification for additional information on how Jayson handles different types of batches, mainly with regards to notifications, request errors and so forth. There is no guarantee that the results will be in the same order as request Array request. To find the right result, compare the ID from the request with the ID in the result yourself. Client callback syntactic sugarWhen the length (number of arguments) of a client callback function is either 2 or 3 it receives slightly different values when invoked. 2 arguments: first argument is an error or null, second argument is the response object as returned (containing either a result or a error property) or null for notifications. 3 arguments: first argument is an error or null, second argument is a JSON-RPC error property or null (if success), third argument is a JSON-RPC result property or null (if error). When doing a batch request with a 3-length callback, the second argument will be an array of requests with a error property and the third argument will be an array of requests with a result property. Client eventsA client will emit the following events (in addition to any special ones emitted by a specific interface): Event When Arguments Notes request About to dispatch a request 1: Request object response Received a response 1: Request object 2: Response object received ServerThe server classes are available as the Server or server property of require('jayson'). The server also sports several interfaces that can be accessed as properties of an instance of Server. Server interface description Name Description Server Base interface for a server that supports receiving JSON-RPC requests Server.tcp TCP server that inherits from net.Server Server.tls TLS server that inherits from tls.Server Server.http HTTP server that inherits from http.Server Server.https HTTPS server that inherits from https.Server Server.middleware Method that returns a Connect/Express compatible middleware function Servers supports these options: Option Default Type Description reviver null Function JSON.parse reviver replacer null Function JSON.stringify replacer router null Function Return the function for method routing collect true Boolean Passed to methodConstructor options params undefined `Array Object null` Passed to methodConstructor options methodConstructor jayson.Method Function Server functions are made an instance of this class version 2 Number JSON-RPC version to support (1 or 2) Server.tcpUses the same options as the base class. Inherits from net.Server. Server.tlsUses the same options as the base class. Inherits from tls.Server. Server.httpUses the same options as the base class. Inherits from http.Server. Server.http Events Event When Arguments Notes http request Incoming HTTP request 1. Instance of http.IncomingMessage http response About to send a HTTP response 1. Instance of http.ServerResponse 2. Instance of http. IncomingMessage Server.httpsUses the same options as the base class. Inherits from https.Server and jayson.Server.http. For information on how to configure certificates, see the documentation on https.Server. Will emit the same custom events as Server.http. Server.middlewareUses the same options as the base class. Returns a function that is compatible with Connect or Express. Will expect the request to be req.body, meaning that the request body must be parsed (typically using connect.bodyParser) before the middleware is invoked. The middleware supports the following options: Option Default Type Description end true Boolean If set to false causes the middleware to next() instead of res.end() when finished. Middleware example in examples/middleware/server.js: var jayson = require(__dirname + '/../..'); var jsonParser = require('body-parser').json; var connect = require('connect'); var app = connect(); var server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); // parse request body before the jayson middleware app.use(jsonParser()); app.use(server.middleware()); app.listen(3000);Many interfaces at the same timeA Jayson server can use many interfaces at the same time. Server example in examples/many_interfaces/server.js that listens to both http and a https requests: var jayson = require(__dirname + '/../..'); var server = jayson.server(); // &quot;http&quot; will be an instance of require('http').Server var http = server.http(); // &quot;https&quot; will be an instance of require('https').Server var https = server.https({ //cert: require('fs').readFileSync('cert.pem'), //key require('fs').readFileSync('key.pem') }); http.listen(80, function() { console.log('Listening on *:80'); }); https.listen(443, function() { console.log('Listening on *:443'); });Using the server as a relayPassing an instance of a client as a method to the server makes the server relay incoming requests to wherever the client is pointing to. This might be used to delegate computationally expensive functions into a separate server or to abstract a cluster of servers behind a common interface. Frontend server example in examples/relay/server_public.js listening on *:3000: var jayson = require(__dirname + '/../..'); // create a server where &quot;add&quot; will relay a localhost-only server var server = jayson.server({ add: jayson.client.http({ port: 3001 }) }); // let the frontend server listen to *:3000 server.http().listen(3000);Backend server example in examples/relay/server_private.js listening on *:3001: var jayson = require(__dirname + '/../..'); var server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); // let the backend listen to *:3001 server.http().listen(3001);Every request to add on the public server will now relay the request to the private server. See the client example in examples/relay/client.js. Method routingPassing a property named router in the server options will enable you to write your own logic for routing requests to specific functions. Server example with custom routing logic in examples/method_routing/server.js: var jayson = require(__dirname + '/../..'); var methods = { add: function(args, callback) { callback(null, args[0] + args[1]); } }; var server = jayson.server(methods, { router: function(method, params) { // regular by-name routing first if(typeof(this._methods[method]) === 'function') return this._methods[method]; if(method === 'add_2') { var fn = server.getMethod('add').getHandler(); return new jayson.Method(function(args, done) { args.unshift(2); fn(args, done); }); } } }); server.http().listen(3000);Client example in examples/method_routing/client.js invoking add_2 on the above server: var jayson = require(__dirname + '/../..'); // create a client var client = jayson.client.http({ port: 3000 }); // invoke &quot;add_2&quot; client.request('add_2', [3], function(err, response) { if(err) throw err; console.log(response.result); // 5! });Server example of nested routes where each property is separated by a dot (you do not need to use the router option for this): var _ = require('lodash'); var jayson = require('jayson'); var methods = { foo: { bar: function(callback) { callback(null, 'ping pong'); } }, math: { add: function(args, callback) { callback(null, args[0] + args[1]); } } }; // this reduction produces an object like this: {'foo.bar': [Function], 'math.add': [Function]} var map = _.reduce(methods, collapse('', '.'), {}); var server = jayson.server(map); function collapse(stem, sep) { return function(map, value, key) { var prop = stem ? stem + sep + key : key; if(_.isFunction(value)) map[prop] = value; else if(_.isObject(value)) map = _.reduce(value, collapse(prop, sep), map); return map; } }Notes If router does not return anything, the reserver will respond with a Method Not Found error. The Server.prototype methods method, methods, removeMethod and hasMethod will not use the router method, but will operate on the internal Server.prototype._methods map. The router method is expected to return instances of jayson.Method (new in 1.2) Method definitionYou can also define server methods inside a wrapping object named jayson.Method. This allows additional options about the method to be specified. Using this wrapper - explicitly or implicitly (via server options) - it is for instance trivial to have your method accept a variable amount of arguments. The method class is available as the Method or method property of require('jayson'). It supports these options: Option Default Type Description handler Function The actual function that will handle a JSON-RPC request to this method collect &gt;= 2.0.0 true before false Boolean Collect JSON-RPC parameters in a single function argument params null `Array Object null` Force JSON-RPC parameters to be of a certain type Server example showcasing most features and options in examples/method_definitions/server.js: var jayson = require(__dirname + '/../..'); var _ = require('lodash'); var methods = { // this function will be wrapped in jayson.Method with options given to the server sum: function(args, done) { done(null, sum(args)); }, // this method gets the raw params as first arg to handler sumCollect: new jayson.Method({ handler: function(args, done) { var total = sum(args); done(null, total); }, collect: true // means &quot;collect all JSON-RPC parameters in one arg&quot; }), // specifies some default values (alternate definition too) sumDefault: jayson.Method(function(args, done) { var total = sum(args); done(null, total); }, { collect: true, params: {a: 2, b: 5} // map of defaults }), // this method returns true when it gets an array (which it always does) isArray: new jayson.Method({ handler: function(args, done) { var result = _.isArray(args); done(null, result); }, collect: true, params: Array // could also be &quot;Object&quot; }) }; var server = jayson.server(methods, { // Given as options to jayson.Method when adding the method &quot;sum&quot; collect: true, params: Array }); server.http().listen(3000); // sums all numbers in an array function sum(list) { return _.reduce(list, function(sum, val) { return sum + val; }, 0); }Client example in examples/method_definitions/client.js: var jayson = require(__dirname + '/../..'); var client = jayson.client.http({ port: 3000 }); // invoke &quot;sumCollect&quot; with array client.request('sumCollect', [3, 5, 9, 11], function(err, response) { if(err) throw err; console.log(response.result); // 28 }); // invoke &quot;sumCollect&quot; with object client.request('sumCollect', {a: 2, b: 3, c: 4}, function(err, response) { if(err) throw err; console.log(response.result); // 9 }); // invoke &quot;sumDefault&quot; with object missing some defined members client.request('sumDefault', {b: 10}, function(err, response) { if(err) throw err; console.log(response.result); // 12 }); // invoke &quot;isArray&quot; with an Object client.request('isArray', {a: 5, b: 2, c: 9}, function(err, response) { if(err) throw err; console.log(response.result); // true }); client.request('sum', [1, 2, 3], function(err, response) { if(err) throw err; console.log(response.result); // 6 });Notes Adding methods as a plain JavaScript function creates an instance of jayson.Method internally. For backwards compatibility it will be created with the option &quot;collect&quot; set to false. It is possible to affect this by passing the collect option to the server. This works similarly for the params option. Server eventsIn addition to events that are specific to certain interfaces, all servers will emit the following events: Event When Arguments Notes request Interpretable non-batch request received 1: Request object response Returning a response 1: Request object 2: Response object batch Interpretable batch request received 1. Array of requests Emits request for every part Server ErrorsIf you should like to return an error from an method request to indicate a failure, remember that the JSON-RPC 2.0 specification requires the error to be an Object with a code (Integer/Number) to be regarded as valid. You can also provide a message (String) and a data (Object) with additional information. Example: var jayson = require('jayson'); var server = jayson.server({ i_cant_find_anything: function(args, callback) { var error = {code: 404, message: 'Cannot find ' + args.id}; callback(error); // will return the error object as given }, i_cant_return_a_valid_error: function(callback) { callback({message: 'I forgot to enter a code'}); // will return a pre-defined &quot;Internal Error&quot; } });Predefined ErrorsIt is also possible to cause a method to return one of the predefined JSON-RPC 2.0 error codes using the server helper function Server.prototype.error inside of a server method. Example: var jayson = require('jayson'); var server = jayson.server({ invalid_params: function(args, callback) { var error = this.error(-32602); // returns an error with the default properties set callback(error); } });You can even override the default messages: var jayson = require('jayson'); var server = jayson.server({ error_giver_of_doom: function(callback) { callback(true) // invalid error format, which causes an Internal Error to be returned instead } }); // Override the default message server.errorMessages[Server.errors.INTERNAL_ERROR] = 'I has a sad. I cant do anything right';Server CORSJayson does not include functionality for supporting CORS requests natively but it is easy to use a CORS-enabling middleware like cors. An example of this can be found in examples/cors/server.js: var jayson = require(__dirname + '/../..'); var cors = require('cors'); var connect = require('connect'); var jsonParser = require('body-parser').json; var app = connect(); var server = jayson.server({ myNameIs: function(args, callback) { callback(null, 'Your name is: ' + args.name); } }); app.use(cors({methods: ['POST']})); app.use(jsonParser()); app.use(server.middleware()); app.listen(3000);Revivers and ReplacersJSON lacks support for representing types other than the simple ones defined in the JSON specification. Fortunately the JSON methods in JavaScript (JSON.parse and JSON.stringify) provide options for custom serialization/deserialization routines. Jayson allows you to pass your own routines as options to both clients and servers. Simple example transferring the state of an object between a client and a server: Shared code between the server and the client in examples/reviving_and_replacing/shared.js: var Counter = exports.Counter = function(value) { this.count = value || 0; }; Counter.prototype.increment = function() { this.count += 1; }; exports.replacer = function(key, value) { if(value instanceof Counter) { return {$class: 'counter', $props: {count: value.count}}; } return value; }; exports.reviver = function(key, value) { if(value &amp;&amp; value.$class === 'counter') { var obj = new Counter(); for(var prop in value.$props) obj[prop] = value.$props[prop]; return obj; } return value; };Server example in examples/reviving_and_replacing/server.js: var jayson = require(__dirname + '/../..'); var shared = require('./shared'); // Set the reviver/replacer options var options = { reviver: shared.reviver, replacer: shared.replacer }; // create a server var server = jayson.server({ increment: function(args, callback) { args.counter.increment(); callback(null, args.counter); } }, options); server.http().listen(3000);A client example in examples/reviving_and_replacing/client.js invoking &quot;increment&quot; on the server: var jayson = require(__dirname + '/../..'); var shared = require('./shared'); var client = jayson.client.http({ port: 3000, reviver: shared.reviver, replacer: shared.replacer }); // create the object var params = { counter: new shared.Counter(2) } // invoke &quot;increment&quot; client.request('increment', params, function(err, response) { if(err) throw err; var result = response.result; console.log( result instanceof shared.Counter, // true result.count, // 3 params.counter === result // false - result is a new object ); });Notes Instead of using a replacer, it is possible to define a toJSON method for any JavaScript object. Unfortunately there is no corresponding method for reviving objects (that would not work, obviously), so the reviver always has to be set up manually. Named parametersIt is possible to specify named parameters when doing a client request by passing an Object instead of an Array. Client example in examples/named_parameters/client.js: var jayson = require(__dirname + '/../..'); var client = jayson.client.http({ port: 3000 }); client.request('add', {b: 1, a: 2}, function(err, response) { if(err) throw err; console.log(response.result); // 3! });Server example in examples/named_parameters/server.js: var jayson = require(__dirname + '/../..'); var server = jayson.server({ add: function(a, b, callback) { callback(null, a + b); } }, { collect: false // don't collect params in a single argument }); server.http().listen(3000);Notes If requesting methods on a Jayson server, arguments left out will be undefined Too many arguments or arguments with invalid names will be ignored It is assumed that the last argument to a server method is the callback and it will not be filled with something else Parsing a function signature and filling in arguments is generally not recommended and should be avoided PromisesSince version 2.0.0 A separate tree that does limited usage of the ES6 Promise object is available. The internal API remains callback based, with the addition that promises may be used for two things: Returning a Promise when requesting a JSON-RPC method using a Client Returning a Promise inside of a Server method To use the separate tree, do a require('jayson/promise') instead of require('jayson'). Server example in examples/promise/server.js showing how to return a Promise in a server method: var jayson = require('../../promise'); var _ = require('lodash'); var server = jayson.server({ add: function(args) { return new Promise(function(resolve, reject) { var sum = _.reduce(args, function(sum, value) { return sum + value; }, 0); resolve(sum); }); } }); server.http().listen(3000);Client example in examples/promise/client.js showing how to do a request: var jayson = require('../../promise'); var client = jayson.client.http({ port: 3000 }); client.request('add', [1, 2, 3, 4, 5]).then(function(response) { console.log(response.result); // 15! });Notes JSON-RPC errors will not result in rejection of the Promise. It is however possible that a future version will include a client setting to have JSON-RPC errors result in rejection. ContributingHighlighting issues or submitting pull requests on Github is most welcome. Please make sure to follow the style of the project, and lint your code with make lint before submitting a patch. × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: Client Client new Client(server, options) Constructor for a Jayson Client Parameters: Name Type Argument Description server Server An instance of Server options Object &lt;optional&gt; Properties Name Type Argument Default Description reviver function &lt;optional&gt; Reviver function for JSON replacer function &lt;optional&gt; Replacer function for JSON version Number &lt;optional&gt; 2 JSON-RPC version to use (1|2) generator function &lt;optional&gt; Function to use for generating request IDs Source: lib/client/index.js, line 5 Returns: Type Client Extends require('events').EventEmitter Members &lt;static&gt; http :ClientHttp HTTP client constructor Type: ClientHttp Source: lib/client/index.js, line 44 &lt;static&gt; https :ClientHttps HTTPS client constructor Type: ClientHttps Source: lib/client/index.js, line 51 &lt;static&gt; tcp :ClientTcp TCP client constructor Type: ClientTcp Source: lib/client/index.js, line 58 &lt;static&gt; tls :ClientTls TLS client constructor Type: ClientTls Source: lib/client/index.js, line 65 Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientHttp.html":{"id":"ClientHttp.html","title":"Class: ClientHttp","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientHttp ClientHttp ClientHttp new ClientHttp(options) Constructor for a Jayson HTTP Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; String interpreted as a URL Properties Name Type Argument Default Description encoding String &lt;optional&gt; &quot;utf8&quot; Encoding to use Source: lib/client/http.js, line 15 Returns: Type ClientHttp Extends Client Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientHttps.html":{"id":"ClientHttps.html","title":"Class: ClientHttps","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientHttps ClientHttps ClientHttps new ClientHttps(options) Constructor for a Jayson HTTPS Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; String interpreted as a URL Properties Name Type Argument Default Description encoding String &lt;optional&gt; &quot;utf8&quot; Encoding to use Source: lib/client/https.js, line 13 Returns: Type ClientHttps Extends ClientHttp Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientTcp.html":{"id":"ClientTcp.html","title":"Class: ClientTcp","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientTcp ClientTcp ClientTcp new ClientTcp(options) Constructor for a Jayson TCP Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; Optional hash of settings or a URL Source: lib/client/tcp.js, line 14 Returns: Type ClientTcp Extends Client Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientTls.html":{"id":"ClientTls.html","title":"Class: ClientTls","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientTls ClientTls ClientTls new ClientTls(options) Constructor for a Jayson TLS-encrypted TCP Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; Optional hash of settings or a URL Source: lib/client/tls.js, line 14 Returns: Type ClientTls Extends Client Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"Jayson.html":{"id":"Jayson.html","title":"Namespace: Jayson","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Jayson Jayson Namespace available as require('jayson') Source: lib/index.js, line 1 Members &lt;static&gt; Client :Client Type: Client Source: lib/index.js, line 11 &lt;static&gt; Method :Method Type: Method Source: lib/index.js, line 29 &lt;static&gt; Server :Server Type: Server Source: lib/index.js, line 17 &lt;static&gt; Utils :Utils Type: Utils Source: lib/index.js, line 23 × Search results Close "},"JaysonPromise.html":{"id":"JaysonPromise.html","title":"Namespace: JaysonPromise","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: JaysonPromise JaysonPromise Namespace available as require('jayson/promise') Source: promise/lib/index.js, line 3 Members &lt;static&gt; Client :PromiseClient Type: PromiseClient Source: promise/lib/index.js, line 13 &lt;static&gt; Method :PromiseMethod Type: PromiseMethod Source: promise/lib/index.js, line 31 &lt;static&gt; Server :Server Type: Server Source: promise/lib/index.js, line 19 &lt;static&gt; Utils :Utils Type: Utils Source: promise/lib/index.js, line 25 × Search results Close "},"Method.html":{"id":"Method.html","title":"Class: Method","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: Method Method new Method(handler, options) Constructor for a Jayson Method Parameters: Name Type Argument Description handler function &lt;optional&gt; Function to set as handler options Object &lt;optional&gt; Properties Name Type Argument Default Description handler function &lt;optional&gt; Same as separate handler collect Boolean &lt;optional&gt; true Params to the handler are collected in one object params Array | Object &lt;optional&gt; Defines params that the handler accepts Source: lib/method.js, line 5 Methods execute(server, requestParams, callback) Executes this method in the context of a server Parameters: Name Type Description server Server requestParams Array | Object callback function Source: lib/method.js, line 114 getHandler() Returns the handler function associated with this method Source: lib/method.js, line 42 Returns: Type function setHandler(handler) Sets the handler function associated with this method Parameters: Name Type Description handler function Source: lib/method.js, line 50 × Search results Close "},"PromiseClient.html":{"id":"PromiseClient.html","title":"Class: PromiseClient","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClient PromiseClient new PromiseClient() Constructor for a Jayson Promise Client Source: promise/lib/client/index.js, line 4 See: Client Returns: Type PromiseClient Extends Client Members &lt;static&gt; http :PromiseClientHttp Type: PromiseClientHttp Source: promise/lib/client/index.js, line 24 &lt;static&gt; https :PromiseClientHttps Type: PromiseClientHttps Source: promise/lib/client/index.js, line 30 &lt;static&gt; tcp :PromiseClientTcp Type: PromiseClientTcp Source: promise/lib/client/index.js, line 42 &lt;static&gt; tls :PromiseClientTls Type: PromiseClientTls Source: promise/lib/client/index.js, line 37 Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientHttp.html":{"id":"PromiseClientHttp.html","title":"Class: PromiseClientHttp","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientHttp PromiseClientHttp new PromiseClientHttp() Constructor for a Jayson Promise Client Http Source: promise/lib/client/http.js, line 4 See: Client Returns: Type PromiseClientHttp Extends ClientHttp Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientHttps.html":{"id":"PromiseClientHttps.html","title":"Class: PromiseClientHttps","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientHttps PromiseClientHttps new PromiseClientHttps() Constructor for a Jayson Promise Client Http Source: promise/lib/client/https.js, line 4 See: Client Returns: Type PromiseClientHttps Extends ClientHttps Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientTcp.html":{"id":"PromiseClientTcp.html","title":"Class: PromiseClientTcp","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientTcp PromiseClientTcp new PromiseClientTcp() Constructor for a Jayson Promise Client Tcp Source: promise/lib/client/tcp.js, line 4 See: Client Returns: Type PromiseClientTcp Extends ClientTcp Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientTls.html":{"id":"PromiseClientTls.html","title":"Class: PromiseClientTls","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientTls PromiseClientTls new PromiseClientTls() Constructor for a Jayson Promise Client Tls Source: promise/lib/client/tls.js, line 4 See: Client Returns: Type PromiseClientTls Extends ClientTls Methods request(method, params, id, callback) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 76 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseMethod.html":{"id":"PromiseMethod.html","title":"Class: PromiseMethod","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseMethod PromiseMethod new PromiseMethod() Constructor for a Jayson Promise Method Source: promise/lib/method.js, line 3 See: Method Returns: Type PromiseMethod Extends Method Methods execute(server, requestParams, outerCallback) Executes this method in the context of a server Parameters: Name Type Description server Server requestParams Array | Object outerCallback function Overrides: Method#execute Source: promise/lib/method.js, line 27 Returns: Type Promise getHandler() Returns the handler function associated with this method Inherited From: Method#getHandler Source: lib/method.js, line 42 Returns: Type function setHandler(handler) Sets the handler function associated with this method Parameters: Name Type Description handler function Inherited From: Method#setHandler Source: lib/method.js, line 50 × Search results Close "},"PromiseServer.html":{"id":"PromiseServer.html","title":"Class: PromiseServer","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseServer PromiseServer new PromiseServer() Constructor for a Jayson Promise Server Source: promise/lib/server.js, line 4 See: Server Returns: Type PromiseServer Extends Server Methods _resolveRouter(method, params) Invoke the router Parameters: Name Type Description method String Method to resolve params Array | Object Request params Inherited From: Server#_resolveRouter Source: lib/server/index.js, line 310 Returns: Type Method call(request, callback) Calls a method on the server Parameters: Name Type Argument Description request Object | Array | String A JSON-RPC request object. Object for single request, Array for batches and String for automatic parsing (using the reviver option) callback function &lt;optional&gt; Callback that receives one of two arguments: first is an error and the second a response Inherited From: Server#call Source: lib/server/index.js, line 216 error(code, message, data) Returns a JSON-RPC compatible error property Parameters: Name Type Argument Default Description code Number &lt;optional&gt; -32603 Error code message String &lt;optional&gt; &quot;Internal error&quot; Error message data Object &lt;optional&gt; Additional data that should be provided Inherited From: Server#error Source: lib/server/index.js, line 197 Returns: Type Object getMethod(name) Gets a method from the server Parameters: Name Type Description name String Inherited From: Server#getMethod Source: lib/server/index.js, line 186 Returns: Type Method hasMethod(name) Checks if a method is registered with the server Parameters: Name Type Description name String Name of method Inherited From: Server#hasMethod Source: lib/server/index.js, line 167 Returns: Type Boolean method(name, definition) Adds a single method to the server Parameters: Name Type Description name String Name of method to add definition function | Client Function or Client for a relayed method Inherited From: Server#method Source: lib/server/index.js, line 118 Throws: Invalid parameters Type TypeError methods(methods) Adds a batch of methods to the server Parameters: Name Type Description methods Object Methods to add Inherited From: Server#methods Source: lib/server/index.js, line 153 removeMethod(name) Removes a method from the server Parameters: Name Type Description name String Inherited From: Server#removeMethod Source: lib/server/index.js, line 175 × Search results Close "},"Server.html":{"id":"Server.html","title":"Class: Server","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: Server Server new Server(methods, options) Constructor for a Jayson Server Parameters: Name Type Argument Description methods Object &lt;optional&gt; Methods to add options Object &lt;optional&gt; Properties Name Type Argument Default Description collect Boolean &lt;optional&gt; true Passed to Jayson.Method as an option when created params Boolean &lt;optional&gt; Passed to Jayson.Method as an option when created reviver function &lt;optional&gt; Reviver function for JSON replacer function &lt;optional&gt; Replacer function for JSON methodConstructor function &lt;optional&gt; Methods will be made instances of this class encoding String &lt;optional&gt; &quot;utf8&quot; Encoding to use version Number &lt;optional&gt; 2 JSON-RPC version to use (1|2) router function &lt;optional&gt; Function to use for routing methods Properties: Name Type Description options Object A reference to the internal options object that can be modified directly errorMessages Object Map of error code to error message pairs that will be used in server responses http ServerHttp HTTP interface constructor https ServerHttps HTTPS interface constructor tcp ServerTcp TCP interface constructor tls ServerTls TLS interface constructor middleware Middleware Middleware generator function Source: lib/server/index.js, line 6 Returns: Type Server Extends require('events').EventEmitter Members &lt;static&gt; errors :Number JSON-RPC specification errors that map to an integer code Type: Number Properties: Name Type Default Description PARSE_ERROR Number -32700 INVALID_REQUEST Number -32600 METHOD_NOT_FOUND Number -32601 INVALID_PARAMS Number -32602 INTERNAL_ERROR Number -32603 Source: lib/server/index.js, line 92 &lt;static&gt; interfaces :function Interfaces that will be automatically bound as properties of a Server instance Type: function Properties: Name Type Default Description http function https function tcp function tls function middleware function Source: lib/server/index.js, line 79 Methods _resolveRouter(method, params) Invoke the router Parameters: Name Type Description method String Method to resolve params Array | Object Request params Source: lib/server/index.js, line 310 Returns: Type Method call(request, callback) Calls a method on the server Parameters: Name Type Argument Description request Object | Array | String A JSON-RPC request object. Object for single request, Array for batches and String for automatic parsing (using the reviver option) callback function &lt;optional&gt; Callback that receives one of two arguments: first is an error and the second a response Source: lib/server/index.js, line 216 error(code, message, data) Returns a JSON-RPC compatible error property Parameters: Name Type Argument Default Description code Number &lt;optional&gt; -32603 Error code message String &lt;optional&gt; &quot;Internal error&quot; Error message data Object &lt;optional&gt; Additional data that should be provided Source: lib/server/index.js, line 197 Returns: Type Object getMethod(name) Gets a method from the server Parameters: Name Type Description name String Source: lib/server/index.js, line 186 Returns: Type Method hasMethod(name) Checks if a method is registered with the server Parameters: Name Type Description name String Name of method Source: lib/server/index.js, line 167 Returns: Type Boolean method(name, definition) Adds a single method to the server Parameters: Name Type Description name String Name of method to add definition function | Client Function or Client for a relayed method Source: lib/server/index.js, line 118 Throws: Invalid parameters Type TypeError methods(methods) Adds a batch of methods to the server Parameters: Name Type Description methods Object Methods to add Source: lib/server/index.js, line 153 removeMethod(name) Removes a method from the server Parameters: Name Type Description name String Source: lib/server/index.js, line 175 × Search results Close "},"ServerHttp.html":{"id":"ServerHttp.html","title":"Class: ServerHttp","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerHttp ServerHttp new ServerHttp(server, options) Constructor for a Jayson HTTP server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/http.js, line 4 Returns: Type ServerHttp Extends require('http').Server × Search results Close "},"ServerHttps.html":{"id":"ServerHttps.html","title":"Class: ServerHttps","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerHttps ServerHttps new ServerHttps(server, options) Constructor for a Jayson HTTPS server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/https.js, line 4 Returns: Type ServerHttps Extends require('https').Server × Search results Close "},"ServerMiddleware.html":{"id":"ServerMiddleware.html","title":"Class: ServerMiddleware","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerMiddleware ServerMiddleware new ServerMiddleware(server, outerOptions) Creates a Connect/Express compatible middleware bound to a Server Parameters: Name Type Argument Description server Server Server instance outerOptions Object &lt;optional&gt; Specific options for the middleware Source: lib/server/middleware.js, line 3 Returns: Type function × Search results Close "},"ServerTcp.html":{"id":"ServerTcp.html","title":"Class: ServerTcp","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerTcp ServerTcp new ServerTcp(server, options) Constructor for a Jayson TCP server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/tcp.js, line 4 Returns: Type ServerTcp Extends require('net').Server × Search results Close "},"ServerTls.html":{"id":"ServerTls.html","title":"Class: ServerTls","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerTls ServerTls new ServerTls(server, options) Constructor for a Jayson TLS-encrypted TCP server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/tls.js, line 4 Returns: Type ServerTls Extends require('tls').Server × Search results Close "},"Utils.html":{"id":"Utils.html","title":"Namespace: Utils","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Utils Utils Source: lib/utils.js, line 6 Namespaces JSON Request Response Methods &lt;static&gt; generateId() Generates a random UUID Source: lib/utils.js, line 87 Returns: Type String &lt;static&gt; parseBody(stream, reviver, callback) Helper to parse a stream and interpret it as JSON Parameters: Name Type Argument Description stream Stream Stream instance reviver function &lt;optional&gt; Optional reviver for JSON.parse callback function Source: lib/utils.js, line 140 &lt;static&gt; parseStream(stream, options, onRequest) Parses an incoming stream for requests using JSONStream Parameters: Name Type Description stream Stream options Object onRequest function Called once for stream errors and an unlimited amount of times for valid requests Source: lib/utils.js, line 110 &lt;static&gt; request(method, params, id, options) Generates a JSON-RPC 1.0 or 2.0 request Parameters: Name Type Argument Description method String Name of method to call params Array | Object Array of parameters passed to the method as specified, or an object of parameter names and corresponding value id String | Number | null &lt;optional&gt; Request ID can be a string, number, null for explicit notification or left out for automatic generation options Object &lt;optional&gt; Properties Name Type Argument Default Description version Number &lt;optional&gt; 2 JSON-RPC version to use (1 or 2) generator function &lt;optional&gt; Function that is passed the request, and the options object and is expected to return a request ID Source: lib/utils.js, line 22 Throws: If any of the parameters are invalid Type TypeError Returns: A JSON-RPC 1.0 or 2.0 request Type Object &lt;static&gt; response(error, result, id, version) Generates a JSON-RPC 1.0 or 2.0 response Parameters: Name Type Description error Object Error member result Object Result member id String | Number | null Id of request version Number JSON-RPC version to use Source: lib/utils.js, line 68 Returns: A JSON-RPC 1.0 or 2.0 response Type Object &lt;static&gt; walk(holder, key, fn) Recursively walk an object and apply a function on its members Parameters: Name Type Description holder Object The object to walk key String The key to look at fn function The function to apply to members Source: lib/utils.js, line 317 Returns: Type Object × Search results Close "},"Utils.JSON.html":{"id":"Utils.JSON.html","title":"Namespace: JSON","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: JSON Utils. JSON Source: lib/utils.js, line 262 Methods &lt;static&gt; parse(str, options) Parses a JSON string and then invokes the given callback Parameters: Name Type Description str String The string to parse options Object Object with options, possibly holding a &quot;reviver&quot; function Source: lib/utils.js, line 269 &lt;static&gt; stringify(obj, options) Stringifies JSON and then invokes the given callback Parameters: Name Type Description obj Object The object to stringify options Object Object with options, possibly holding a &quot;replacer&quot; function Source: lib/utils.js, line 292 × Search results Close "},"Utils.Request.html":{"id":"Utils.Request.html","title":"Namespace: Request","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Request Utils. Request Source: lib/utils.js, line 335 Methods &lt;static&gt; isBatch(request) Determines if the passed request is a batch request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 342 Returns: Type Boolean &lt;static&gt; isNotification(request) Determines if the passed request is a notification request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 351 Returns: Type Boolean &lt;static&gt; isValidRequest(request, version) Determines if the passed request is a valid JSON-RPC Request Parameters: Name Type Description request Object The request version Number JSON-RPC version 1 or 2 Source: lib/utils.js, line 406 Returns: Type Boolean &lt;static&gt; isValidVersionOneRequest(request) Determines if the passed request is a valid JSON-RPC 1.0 Request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 390 Returns: Type Boolean &lt;static&gt; isValidVersionTwoRequest(request) Determines if the passed request is a valid JSON-RPC 2.0 Request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 365 Returns: Type Boolean × Search results Close "},"Utils.Response.html":{"id":"Utils.Response.html","title":"Namespace: Response","body":" Jayson Namespaces JaysonJaysonPromiseUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Response Utils. Response Source: lib/utils.js, line 418 Methods &lt;static&gt; isValidError(error, version) Determines if the passed error is a valid JSON-RPC error response Parameters: Name Type Description error Object The error version Number JSON-RPC version 1 or 2 Source: lib/utils.js, line 426 Returns: Type Boolean × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
