<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_client_index.js.html":{"id":"lib_client_index.js.html","title":"Source: lib/client/index.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/index.js 'use strict'; const _ = require('lodash'); const utils = require('../utils'); const events = require('events'); /** * Constructor for a Jayson Client * @class Client * @extends require('events').EventEmitter * @param {Server} [server] An instance of Server (a object with a &quot;call&quot; method&quot;) * @param {Object} [options] * @param {Function} [options.reviver] Reviver function for JSON * @param {Function} [options.replacer] Replacer function for JSON * @param {Number} [options.version=2] JSON-RPC version to use (1|2) * @param {Function} [options.generator] Function to use for generating request IDs * @return {Client} */ const Client = function(server, options) { if(arguments.length === 1 &amp;&amp; _.isPlainObject(server)) { options = server; server = null; } if(!(this instanceof Client)) { return new Client(server, options); } const defaults = { reviver: null, replacer: null, generator: utils.generateId, version: 2 }; this.options = utils.merge(defaults, options || {}); if(server) { this.server = server; } }; require('util').inherits(Client, events.EventEmitter); module.exports = Client; /** * HTTP client constructor * @type ClientHttp * @static */ Client.http = require('./http'); /** * HTTPS client constructor * @type ClientHttps * @static */ Client.https = require('./https'); /** * TCP client constructor * @type ClientTcp * @static */ Client.tcp = require('./tcp'); /** * TLS client constructor * @type ClientTls * @static */ Client.tls = require('./tls'); /** * Browser client constructor * @type ClientBrowser * @static */ Client.browser = require('./browser'); /** * Creates a request and dispatches it if given a callback. * @param {String|Array} method A batch request if passed an Array, or a method name if passed a String * @param {Array|Object} params Parameters for the method * @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request * @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it. * @throws {TypeError} Invalid parameters * @return {Object} JSON-RPC 1.0 or 2.0 compatible request */ Client.prototype.request = function(method, params, id, callback) { const self = this; let request = null; // is this a batch request? const isBatch = Array.isArray(method) &amp;&amp; typeof(params) === 'function'; if (this.options.version === 1 &amp;&amp; isBatch) { throw new TypeError('JSON-RPC 1.0 does not support batching'); } // is this a raw request? const isRaw = !isBatch &amp;&amp; method &amp;&amp; typeof(method) === 'object' &amp;&amp; typeof(params) === 'function'; if(isBatch || isRaw) { callback = params; request = method; } else { if(typeof(id) === 'function') { callback = id; // specifically undefined because &quot;null&quot; is a notification request id = undefined; } const hasCallback = typeof(callback) === 'function'; try { request = utils.request(method, params, id, { generator: this.options.generator, version: this.options.version }); } catch(err) { if(hasCallback) { callback(err); return; } throw err; } // no callback means we should just return a raw request before sending if(!hasCallback) { return request; } } this.emit('request', request); this._request(request, function(err, response) { self.emit('response', request, response); self._parseResponse(err, response, callback); }); // always return the raw request return request; }; /** * Executes a request on a directly bound server * @param {Object} request A JSON-RPC 1.0 or 2.0 request * @param {Function} callback Request callback that will receive the server response as the second argument * @private */ Client.prototype._request = function(request, callback) { const self = this; // serializes the request as a JSON string so that we get a copy and can run the replacer as intended utils.JSON.stringify(request, this.options, function(err, message) { if(err) { callback(err); return; } self.server.call(message, function(error, success) { const response = error || success; callback(null, response); }); }); }; /** * Parses a response from a server * @param {Object} err Error to pass on that is unrelated to the actual response * @param {Object} response JSON-RPC 1.0 or 2.0 response * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters * @private */ Client.prototype._parseResponse = function(err, response, callback) { if(err) { return callback(err); } if(!response || typeof(response) !== 'object') { return callback(); } if(callback.length === 3) { // if callback length is 3, we split callback arguments on error and response // is batch response? if(Array.isArray(response)) { // neccesary to split strictly on validity according to spec here const isError = function(res) { return typeof(res.error) !== 'undefined'; }; const isNotError = function(res) { return !isError(res); }; return callback(null, response.filter(isError), response.filter(isNotError)); } else { // split regardless of validity return callback(null, response.error, response.result); } } return callback(null, response); }; × Search results Close "},"lib_client_browser.js.html":{"id":"lib_client_browser.js.html","title":"Source: lib/client/browser.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/browser.js 'use strict'; const extend = require('lodash/extend'); const isArray = require('lodash/isArray'); const isFunction = require('lodash/isFunction'); const isObject = require('lodash/isObject'); const isUndefined = require('lodash/isUndefined'); const negate = require('lodash/negate'); const uuid = require('uuid/v4'); const generateRequest = require('../generateRequest'); /** * Constructor for a Jayson Browser Client that does not depend any node.js core libraries * @class ClientBrowser * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback * @param {Object} [options] * @param {Function} [options.reviver] Reviver function for JSON * @param {Function} [options.replacer] Replacer function for JSON * @param {Number} [options.version=2] JSON-RPC version to use (1|2) * @param {Function} [options.generator] Function to use for generating request IDs * @return {ClientBrowser} */ const ClientBrowser = function(callServer, options) { if(!(this instanceof ClientBrowser)) { return new ClientBrowser(callServer, options); } const defaults = { reviver: null, replacer: null, generator: function() { return uuid(); }, version: 2 }; this.options = extend(defaults, options || {}); this.callServer = callServer; }; module.exports = ClientBrowser; /** * Creates a request and dispatches it if given a callback. * @param {String|Array} method A batch request if passed an Array, or a method name if passed a String * @param {Array|Object} [params] Parameters for the method * @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request * @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it. * @throws {TypeError} Invalid parameters * @return {Object} JSON-RPC 1.0 or 2.0 compatible request */ ClientBrowser.prototype.request = function(method, params, id, callback) { const self = this; let request = null; // is this a batch request? const isBatch = isArray(method) &amp;&amp; isFunction(params); if (this.options.version === 1 &amp;&amp; isBatch) { throw new TypeError('JSON-RPC 1.0 does not support batching'); } // is this a raw request? const isRaw = !isBatch &amp;&amp; method &amp;&amp; isObject(method) &amp;&amp; isFunction(params); if(isBatch || isRaw) { callback = params; request = method; } else { if(isFunction(id)) { callback = id; // specifically undefined because &quot;null&quot; is a notification request id = undefined; } const hasCallback = isFunction(callback); try { request = generateRequest(method, params, id, { generator: this.options.generator, version: this.options.version }); } catch(err) { if(hasCallback) { return callback(err); } throw err; } // no callback means we should just return a raw request if(!hasCallback) { return request; } } let message; try { message = JSON.stringify(request, this.options.replacer); } catch(err) { return callback(err); } this.callServer(message, function(err, response) { self._parseResponse(err, response, callback); }); // always return the raw request return request; }; /** * Parses a response from a server * @param {Object} err Error to pass on that is unrelated to the actual response * @param {String} responseText JSON-RPC 1.0 or 2.0 response * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters * @private */ ClientBrowser.prototype._parseResponse = function(err, responseText, callback) { if(err) { callback(err); return; } if(!responseText) { // empty response text, assume that is correct because it could be a // notification which jayson does not give any body for return callback(); } let response; try { response = JSON.parse(responseText, this.options.reviver); } catch(err) { return callback(err); } if(callback.length === 3) { // if callback length is 3, we split callback arguments on error and response // is batch response? if(isArray(response)) { // neccesary to split strictly on validity according to spec here const isError = function(res) { return !isUndefined(res.error); }; return callback(null, response.filter(isError), response.filter(negate(isError))); } else { // split regardless of validity return callback(null, response.error, response.result); } } callback(null, response); }; × Search results Close "},"lib_client_http.js.html":{"id":"lib_client_http.js.html","title":"Source: lib/client/http.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/http.js 'use strict'; const http = require('http'); const url = require('url'); const utils = require('../utils'); const Client = require('../client'); /** * Constructor for a Jayson HTTP Client * @class ClientHttp * @constructor * @extends Client * @param {Object|String} [options] String interpreted as a URL * @param {String} [options.encoding=&quot;utf8&quot;] Encoding to use * @return {ClientHttp} */ const ClientHttp = function(options) { // accept first parameter as a url string if(typeof(options) === 'string') { options = url.parse(options); } if(!(this instanceof ClientHttp)) { return new ClientHttp(options); } Client.call(this, options); const defaults = utils.merge(this.options, { encoding: 'utf8' }); this.options = utils.merge(defaults, options || {}); }; require('util').inherits(ClientHttp, Client); module.exports = ClientHttp; ClientHttp.prototype._request = function(request, callback) { const self = this; // copies options so object can be modified in this context const options = utils.merge({}, this.options); utils.JSON.stringify(request, options, function(err, body) { if(err) { return callback(err); } options.method = options.method || 'POST'; const headers = { 'Content-Length': Buffer.byteLength(body, options.encoding), 'Content-Type': 'application/json; charset=utf-8', 'Accept': 'application/json' }; // let user override the headers options.headers = utils.merge(headers, options.headers || {}); const req = self._getRequestStream(options); self.emit('http request', req); req.on('response', function(res) { self.emit('http response', res, req); res.setEncoding(options.encoding); let data = ''; res.on('data', function(chunk) { data += chunk; }); res.on('end', function() { // assume we have an error if(res.statusCode &lt; 200 || res.statusCode &gt;= 300) { // assume the server gave the reason in the body const err = new Error(data); err.code = res.statusCode; callback(err); } else { // empty reply if(!data || typeof(data) !== 'string') { return callback(); } utils.JSON.parse(data, options, callback); } }); }); // abort on timeout req.on('timeout', function() { req.abort(); // req.abort causes &quot;error&quot; event }); // abort on error req.on('error', function(err) { self.emit('http error', err); callback(err); req.abort(); }); req.end(body); }); }; /** * Gets a stream interface to a http server * @param {Object} options An options object * @return {require('http').ClientRequest} * @private */ ClientHttp.prototype._getRequestStream = function(options) { return http.request(options || {}); }; × Search results Close "},"lib_client_https.js.html":{"id":"lib_client_https.js.html","title":"Source: lib/client/https.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/https.js 'use strict'; const https = require('https'); const ClientHttp = require('./http'); /** * Constructor for a Jayson HTTPS Client * @class ClientHttps * @constructor * @extends ClientHttp * @param {Object|String} [options] String interpreted as a URL * @param {String} [options.encoding=&quot;utf8&quot;] Encoding to use * @return {ClientHttps} */ const ClientHttps = function(options) { if(!(this instanceof ClientHttps)) { return new ClientHttps(options); } // just proxy to constructor for ClientHttp ClientHttp.call(this, options); }; require('util').inherits(ClientHttps, ClientHttp); module.exports = ClientHttps; /** * Gets a stream interface to a https server * @param {Object} options An options object * @return {require('https').ClientRequest} * @private */ ClientHttps.prototype._getRequestStream = function(options) { return https.request(options || {}); }; × Search results Close "},"lib_client_tcp.js.html":{"id":"lib_client_tcp.js.html","title":"Source: lib/client/tcp.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/tcp.js 'use strict'; const net = require('net'); const url = require('url'); const utils = require('../utils'); const Client = require('../client'); /** * Constructor for a Jayson TCP Client * @class ClientTcp * @constructor * @extends Client * @param {Object|String} [options] Optional hash of settings or a URL * @return {ClientTcp} */ const ClientTcp = function(options) { // accept first parameter as a url string if(typeof(options) === 'string') { options = url.parse(options); } if(!(this instanceof ClientTcp)) { return new ClientTcp(options); } Client.call(this, options); const defaults = utils.merge(this.options, { encoding: 'utf8' }); this.options = utils.merge(defaults, options || {}); }; require('util').inherits(ClientTcp, Client); module.exports = ClientTcp; ClientTcp.prototype._request = function(request, callback) { const self = this; // copies options so object can be modified in this context const options = utils.merge({}, this.options); utils.JSON.stringify(request, options, function(err, body) { if(err) { return callback(err); } let handled = false; const conn = net.connect(options, function() { conn.setEncoding(options.encoding); // wont get anything for notifications, just end here if(utils.Request.isNotification(request)) { handled = true; conn.end(body + '\\n'); callback(); } else { utils.parseStream(conn, options, function(err, response) { handled = true; conn.end(); if(err) { return callback(err); } callback(null, response); }); conn.write(body + '\\n'); } }); conn.on('error', function(err) { self.emit('tcp error', err); callback(err); }); conn.on('end', function() { if(!handled) { callback(); } }); }); }; × Search results Close "},"lib_client_tls.js.html":{"id":"lib_client_tls.js.html","title":"Source: lib/client/tls.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/client/tls.js 'use strict'; const tls = require('tls'); const url = require('url'); const utils = require('../utils'); const Client = require('../client'); /** * Constructor for a Jayson TLS-encrypted TCP Client * @class ClientTls * @constructor * @extends Client * @param {Object|String} [options] Optional hash of settings or a URL * @return {ClientTls} */ const ClientTls = function(options) { // accept first parameter as a url string if(typeof(options) === 'string') { options = url.parse(options); } if(!(this instanceof ClientTls)) { return new ClientTls(options); } Client.call(this, options); const defaults = utils.merge(this.options, { encoding: 'utf8' }); this.options = utils.merge(defaults, options || {}); }; require('util').inherits(ClientTls, Client); module.exports = ClientTls; ClientTls.prototype._request = function(request, callback) { const self = this; // copies options so object can be modified in this context const options = utils.merge({}, this.options); utils.JSON.stringify(request, options, function(err, body) { if(err) { return callback(err); } let handled = false; const conn = tls.connect(options, function() { conn.setEncoding(options.encoding); // wont get anything for notifications, just end here if(utils.Request.isNotification(request)) { handled = true; conn.end(body + '\\n'); callback(); } else { utils.parseStream(conn, options, function(err, response) { handled = true; conn.end(); if(err) { return callback(err); } callback(null, response); }); conn.write(body + '\\n'); } }); conn.on('error', function(err) { self.emit('tcp error', err); callback(err); }); conn.on('end', function() { if(!handled) { callback(); } }); }); }; × Search results Close "},"lib_index.js.html":{"id":"lib_index.js.html","title":"Source: lib/index.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/index.js 'use strict'; /** * Namespace available as require('jayson') * @namespace Jayson */ const Jayson = module.exports; /** * @static * @type Client */ Jayson.Client = Jayson.client = require('./client'); /** * @static * @type Server */ Jayson.Server = Jayson.server = require('./server'); /** * @static * @type Utils */ Jayson.Utils = Jayson.utils = require('./utils'); /** * @static * @type Method */ Jayson.Method = Jayson.method = require('./method'); × Search results Close "},"promise_lib_index.js.html":{"id":"promise_lib_index.js.html","title":"Source: promise/lib/index.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/index.js 'use strict'; const Jayson = require('../..'); /** * Namespace available as require('jayson/promise') * @namespace JaysonPromise */ const JaysonPromise = module.exports; /** * @static * @type PromiseClient */ JaysonPromise.Client = JaysonPromise.client = require('./client'); /** * @static * @type Server */ JaysonPromise.Server = JaysonPromise.server = require('./server'); /** * @static * @type Utils */ JaysonPromise.Utils = JaysonPromise.utils = Jayson.utils; /** * @static * @type PromiseMethod */ JaysonPromise.Method = JaysonPromise.method = require('./method'); × Search results Close "},"lib_method.js.html":{"id":"lib_method.js.html","title":"Source: lib/method.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/method.js 'use strict'; const utils = require('./utils'); const _ = require('lodash'); /** * @summary Constructor for a Jayson Method * @class Method * @param {Function} [handler] Function to set as handler * @param {Object} [options] * @param {Function} [options.handler] Same as separate handler * @param {Boolean} [options.useContext=false] When true, the handler expects a context object * @param {Array|Object} [options.params] Defines params that the handler accepts */ const Method = function(handler, options) { if(!(this instanceof Method)) { return new Method(handler, options); } // only got passed options if(_.isPlainObject(handler)) { options = handler; handler = null; } const defaults = { useContext: false, }; options = options || {}; this.options = utils.merge(defaults, options); this.handler = handler || options.handler; }; module.exports = Method; /** * @summary Returns the handler function associated with this method * @return {Function} */ Method.prototype.getHandler = function() { return this.handler; }; /** * @summary Sets the handler function associated with this method * @param {Function} handler */ Method.prototype.setHandler = function(handler) { this.handler = handler; }; /** * @summary Prepare parameters for the method handler * @private */ Method.prototype._getHandlerParams = function(params) { const options = this.options; const isObjectParams = !_.isArray(params) &amp;&amp; _.isObject(params) &amp;&amp; params; const isArrayParams = _.isArray(params); switch(true) { // handler always gets an array case options.params === Array: return isArrayParams ? params : _.toArray(params); // handler always gets an object case options.params === Object: return isObjectParams ? params : _.toPlainObject(params); // handler gets a list of defined properties that should always be set case _.isArray(options.params): { const undefinedParams = _.reduce(options.params, function(undefinedParams, key) { undefinedParams[key] = undefined; return undefinedParams; }, {}); return _.extend(undefinedParams, _.pick(params, _.keys(params))); } // handler gets a map of defined properties and their default values case _.isPlainObject(options.params): return _.extend({}, options.params, _.pick(params, _.keys(params))); // give params as is default: return params; } }; /** * @summary Executes this method in the context of a server * @param {Server} server * @param {Array|Object} requestParams * @param {Object} [context] * @param {Function} callback */ Method.prototype.execute = function(server, requestParams, context, callback) { if(typeof(context) === 'function') { callback = context; context = {}; } if(!context) { context = {}; } // when useContext is true, the handler gets a context object every time const useContext = Boolean(this.options.useContext); const handler = this.getHandler(); const params = this._getHandlerParams(requestParams); const args = useContext ? [params, context, callback] : [params, callback]; return handler.call(server, ...args); }; × Search results Close "},"lib_generateRequest.js.html":{"id":"lib_generateRequest.js.html","title":"Source: lib/generateRequest.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/generateRequest.js 'use strict'; const isString = require('lodash/isString'); const isUndefined = require('lodash/isUndefined'); const isObject = require('lodash/isObject'); const isArray = require('lodash/isArray'); const isFunction = require('lodash/isFunction'); const uuid = require('uuid/v4'); /** * Generates a JSON-RPC 1.0 or 2.0 request * @param {String} method Name of method to call * @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value * @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation * @param {Object} [options] * @param {Number} [options.version=2] JSON-RPC version to use (1 or 2) * @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID * @throws {TypeError} If any of the parameters are invalid * @return {Object} A JSON-RPC 1.0 or 2.0 request */ module.exports = function(method, params, id, options) { if(!isString(method)) { throw new TypeError(method + ' must be a string'); } options = options || {}; const request = { method: method }; // assume that we are doing a 2.0 request unless specified differently if(isUndefined(options.version) || options.version !== 1) { request.jsonrpc = '2.0'; } if(params) { // params given, but invalid? if(!isObject(params) &amp;&amp; !isArray(params)) { throw new TypeError(params + ' must be an object, array or omitted'); } request.params = params; } // if id was left out, generate one (null means explicit notification) if(typeof(id) === 'undefined') { const generator = isFunction(options.generator) ? options.generator : function() { return uuid(); }; request.id = generator(request, options); } else { request.id = id; } return request; }; × Search results Close "},"promise_lib_client_index.js.html":{"id":"promise_lib_client_index.js.html","title":"Source: promise/lib/client/index.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/index.js 'use strict'; const promisify = require('es6-promisify'); const jayson = require('../../../'); const promiseUtils = require('../utils'); /** * Constructor for a Jayson Promise Client * @see Client * @class PromiseClient * @extends Client * @return {PromiseClient} */ const PromiseClient = function(server, options) { if(!(this instanceof PromiseClient)) { return new PromiseClient(server, options); } jayson.Client.apply(this, arguments); this.request = promiseUtils.wrapClientRequestMethod(this.request.bind(this)); }; require('util').inherits(PromiseClient, jayson.Client); /** * @type PromiseClientHttp * @static */ PromiseClient.http = require('./http'); /** * @type PromiseClientHttps * @static */ PromiseClient.https = require('./https'); /** * @type PromiseClientTls * @static */ PromiseClient.tls = require('./tls'); /** * @type PromiseClientTcp * @static */ PromiseClient.tcp = require('./tcp'); module.exports = PromiseClient; × Search results Close "},"promise_lib_client_http.js.html":{"id":"promise_lib_client_http.js.html","title":"Source: promise/lib/client/http.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/http.js 'use strict'; const promisify = require('es6-promisify'); const jayson = require('../../../'); const promiseUtils = require('../utils'); /** * Constructor for a Jayson Promise Client Http * @see Client * @class PromiseClientHttp * @extends ClientHttp * @return {PromiseClientHttp} */ const PromiseClientHttp = function(options) { if(!(this instanceof PromiseClientHttp)) { return new PromiseClientHttp(options); } jayson.Client.http.apply(this, arguments); this.request = promiseUtils.wrapClientRequestMethod(this.request.bind(this)); }; require('util').inherits(PromiseClientHttp, jayson.Client.http); module.exports = PromiseClientHttp; × Search results Close "},"promise_lib_client_https.js.html":{"id":"promise_lib_client_https.js.html","title":"Source: promise/lib/client/https.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/https.js 'use strict'; const promisify = require('es6-promisify'); const jayson = require('../../../'); const promiseUtils = require('../utils'); /** * Constructor for a Jayson Promise Client Http * @see Client * @class PromiseClientHttps * @extends ClientHttps * @return {PromiseClientHttps} */ const PromiseClientHttps = function(options) { if(!(this instanceof PromiseClientHttps)) { return new PromiseClientHttps(options); } jayson.Client.https.apply(this, arguments); this.request = promiseUtils.wrapClientRequestMethod(this.request.bind(this)); }; require('util').inherits(PromiseClientHttps, jayson.Client.https); module.exports = PromiseClientHttps; × Search results Close "},"promise_lib_client_tcp.js.html":{"id":"promise_lib_client_tcp.js.html","title":"Source: promise/lib/client/tcp.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/tcp.js 'use strict'; const promisify = require('es6-promisify'); const jayson = require('../../../'); const promiseUtils = require('../utils'); /** * Constructor for a Jayson Promise Client Tcp * @see Client * @class PromiseClientTcp * @extends ClientTcp * @return {PromiseClientTcp} */ const PromiseClientTcp = function(options) { if(!(this instanceof PromiseClientTcp)) { return new PromiseClientTcp(options); } jayson.Client.tcp.apply(this, arguments); this.request = promiseUtils.wrapClientRequestMethod(this.request.bind(this)); }; require('util').inherits(PromiseClientTcp, jayson.Client.tcp); module.exports = PromiseClientTcp; × Search results Close "},"promise_lib_client_tls.js.html":{"id":"promise_lib_client_tls.js.html","title":"Source: promise/lib/client/tls.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/client/tls.js 'use strict'; const promisify = require('es6-promisify'); const jayson = require('../../../'); const promiseUtils = require('../utils'); /** * Constructor for a Jayson Promise Client Tls * @see Client * @class PromiseClientTls * @extends ClientTls * @return {PromiseClientTls} */ const PromiseClientTls = function(options) { if(!(this instanceof PromiseClientTls)) { return new PromiseClientTls(options); } jayson.Client.tls.apply(this, arguments); this.request = promiseUtils.wrapClientRequestMethod(this.request.bind(this)); }; require('util').inherits(PromiseClientTls, jayson.Client.tls); module.exports = PromiseClientTls; × Search results Close "},"promise_lib_method.js.html":{"id":"promise_lib_method.js.html","title":"Source: promise/lib/method.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/method.js 'use strict'; const jayson = require('../../'); const _ = require('lodash'); /** * Constructor for a Jayson Promise Method * @see Method * @class PromiseMethod * @extends Method * @return {PromiseMethod} */ const PromiseMethod = module.exports = function(handler, options) { if(!(this instanceof PromiseMethod)) { return new PromiseMethod(handler, options); } jayson.Method.apply(this, arguments); }; require('util').inherits(PromiseMethod, jayson.Method); module.exports = PromiseMethod; /** * @summary Executes this method in the context of a server * @param {Server} server * @param {Array|Object} requestParams * @param {Function} outerCallback * @return {Promise} */ PromiseMethod.prototype.execute = function(server, requestParams, context, outerCallback) { let wasPromised = false; if(typeof(context) === 'function') { outerCallback = context; context = {}; } const promise = jayson.Method.prototype.execute.call(this, server, requestParams, context, function() { if(wasPromised) { return; // ignore any invocations of the callback if a promise was returned } outerCallback.apply(null, arguments); }); wasPromised = promise &amp;&amp; _.isFunction(promise.then); // if the handler returned a promise, call the callback when it resolves if(wasPromised) { return promise.then( function(fulfilled) { outerCallback(null, fulfilled); }, function(rejected) { outerCallback(rejected); } ); } }; × Search results Close "},"promise_lib_server.js.html":{"id":"promise_lib_server.js.html","title":"Source: promise/lib/server.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/server.js 'use strict'; const Method = require('./method'); const jayson = require('../../'); /** * Constructor for a Jayson Promise Server * @see Server * @class PromiseServer * @extends Server * @return {PromiseServer} */ const PromiseServer = function(methods, options) { if(!(this instanceof PromiseServer)) { return new PromiseServer(methods, options); } options = options || {}; options.methodConstructor = options.methodConstructor || Method; jayson.Server.call(this, methods, options); }; require('util').inherits(PromiseServer, jayson.Server); module.exports = PromiseServer; × Search results Close "},"lib_server_index.js.html":{"id":"lib_server_index.js.html","title":"Source: lib/server/index.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/index.js 'use strict'; const jayson = require('../'); const events = require('events'); const _ = require('lodash'); const utils = require('../utils'); /** * Constructor for a Jayson Server * @class Server * @extends require('events').EventEmitter * @param {Object&lt;String,Function&gt;} [methods] Methods to add * @param {Object} [options] * @param {Array|Object} [options.params] Passed to Jayson.Method as an option when created * @param {Boolean} [options.useContext=false] Passed to Jayson.Method as an option when created * @param {Function} [options.reviver] Reviver function for JSON * @param {Function} [options.replacer] Replacer function for JSON * @param {Function} [options.methodConstructor] Methods will be made instances of this class * @param {String} [options.encoding=&quot;utf8&quot;] Encoding to use * @param {Number} [options.version=2] JSON-RPC version to use (1|2) * @param {Function} [options.router] Function to use for routing methods * @property {Object} options A reference to the internal options object that can be modified directly * @property {Object} errorMessages Map of error code to error message pairs that will be used in server responses * @property {ServerHttp} http HTTP interface constructor * @property {ServerHttps} https HTTPS interface constructor * @property {ServerTcp} tcp TCP interface constructor * @property {ServerTls} tls TLS interface constructor * @property {Middleware} middleware Middleware generator function * @return {Server} */ const Server = function(methods, options) { if(!(this instanceof Server)) { return new Server(methods, options); } const defaults = { reviver: null, replacer: null, encoding: 'utf8', version: 2, useContext: false, methodConstructor: jayson.Method, router: function(method) { return this.getMethod(method); } }; this.options = utils.merge(defaults, options || {}); // bind router to the server this.options.router = this.options.router.bind(this); this._methods = {}; // adds methods passed to constructor this.methods(methods || {}); // assigns interfaces to this instance const interfaces = Server.interfaces; for(let name in interfaces) { this[name] = interfaces[name].bind(interfaces[name], this); } // copies error messages for defined codes into this instance this.errorMessages = {}; for(let handle in Server.errors) { const code = Server.errors[handle]; this.errorMessages[code] = Server.errorMessages[code]; } }; require('util').inherits(Server, events.EventEmitter); module.exports = Server; /** * Interfaces that will be automatically bound as properties of a Server instance * @enum {Function} * @static */ Server.interfaces = { http: require('./http'), https: require('./https'), tcp: require('./tcp'), tls: require('./tls'), middleware: require('./middleware') }; /** * JSON-RPC specification errors that map to an integer code * @enum {Number} * @static */ Server.errors = { PARSE_ERROR: -32700, INVALID_REQUEST: -32600, METHOD_NOT_FOUND: -32601, INVALID_PARAMS: -32602, INTERNAL_ERROR: -32603 }; /* * Error codes that map to an error message * @enum {String} * @static */ Server.errorMessages = {}; Server.errorMessages[Server.errors.PARSE_ERROR] = 'Parse Error'; Server.errorMessages[Server.errors.INVALID_REQUEST] = 'Invalid request'; Server.errorMessages[Server.errors.METHOD_NOT_FOUND] = 'Method not found'; Server.errorMessages[Server.errors.INVALID_PARAMS] = 'Invalid method parameter(s)'; Server.errorMessages[Server.errors.INTERNAL_ERROR] = 'Internal error'; /** * Adds a single method to the server * @param {String} name Name of method to add * @param {Function|Client} definition Function or Client for a relayed method * @throws {TypeError} Invalid parameters */ Server.prototype.method = function(name, definition) { const Method = this.options.methodConstructor; const isRelay = definition instanceof jayson.Client; const isMethod = definition instanceof Method; const isFunction = _.isFunction(definition); // a valid method is either a function or a client (relayed method) if(!isRelay &amp;&amp; !isMethod &amp;&amp; !isFunction) { throw new TypeError('method definition must be either a function, an instance of jayson.Client or an instance of jayson.Method'); } if(!name || typeof(name) !== 'string') { throw new TypeError('&quot;' + name + '&quot; must be a non-zero length string'); } if(/^rpc\\./.test(name)) { throw new TypeError('&quot;' + name + '&quot; is a reserved method name'); } // make instance of jayson.Method if(!isRelay &amp;&amp; !isMethod) { definition = new Method(definition, { params: this.options.params, useContext: this.options.useContext }); } this._methods[name] = definition; }; /** * Adds a batch of methods to the server * @param {Object} methods Methods to add */ Server.prototype.methods = function(methods) { methods = methods || {}; for(let name in methods) { this.method(name, methods[name]); } }; /** * Checks if a method is registered with the server * @param {String} name Name of method * @return {Boolean} */ Server.prototype.hasMethod = function(name) { return name in this._methods; }; /** * Removes a method from the server * @param {String} name */ Server.prototype.removeMethod = function(name) { if(this.hasMethod(name)) { delete this._methods[name]; } }; /** * Gets a method from the server * @param {String} name * @return {Method} */ Server.prototype.getMethod = function(name) { return this._methods[name]; }; /** * Returns a JSON-RPC compatible error property * @param {Number} [code=-32603] Error code * @param {String} [message=&quot;Internal error&quot;] Error message * @param {Object} [data] Additional data that should be provided * @return {Object} */ Server.prototype.error = function(code, message, data) { if(typeof(code) !== 'number') { code = Server.errors.INTERNAL_ERROR; } if(typeof(message) !== 'string') { message = this.errorMessages[code] || ''; } const error = { code: code, message: message }; if(typeof(data) !== 'undefined') { error.data = data; } return error; }; /** * Calls a method on the server * @param {Object|Array|String} request A JSON-RPC request object. Object for single request, Array for batches and String for automatic parsing (using the reviver option) * @param {Object} [context] Optional context object passed to methods * @param {Function} [callback] Callback that receives one of two arguments: first is an error and the second a response */ Server.prototype.call = function(request, context, originalCallback) { const self = this; if(typeof(context) === 'function') { originalCallback = context; context = {}; } if(typeof(context) === 'undefined') { context = {}; } if(typeof(originalCallback) !== 'function') { originalCallback = function() {}; } // compose the callback so that we may emit an event on every response const callback = function(error, response) { self.emit('response', request, response || error); originalCallback.apply(null, arguments); }; maybeParse(request, this.options, function(err, request) { let error = null; // JSON-RPC error if(err) { error = self.error(Server.errors.PARSE_ERROR, null, err); callback(utils.response(error, undefined, undefined, self.options.version)); return; } // is this a batch request? if(utils.Request.isBatch(request)) { // batch requests not allowed for version 1 if(self.options.version === 1) { error = self.error(Server.errors.INVALID_REQUEST); callback(utils.response(error, undefined, undefined, self.options.version)); return; } // special case if empty batch request if(!request.length) { error = self.error(Server.errors.INVALID_REQUEST); callback(utils.response(error, undefined, undefined, self.options.version)); return; } self._batch(request, context, callback); return; } self.emit('request', request); // is the request valid? if(!utils.Request.isValidRequest(request, self.options.version)) { error = self.error(Server.errors.INVALID_REQUEST); callback(utils.response(error, undefined, undefined, self.options.version)); return; } // from now on we are &quot;notification-aware&quot; and can deliberately ignore errors for such requests const respond = function(error, result) { if(utils.Request.isNotification(request)) { callback(); return; } const response = utils.response(error, result, request.id, self.options.version); if(response.error) { callback(response); } else { callback(null, response); } }; const method = self._resolveRouter(request.method, request.params); // are we attempting to invoke a relayed method? if(method instanceof jayson.Client) { return method.request(request.method, request.params, request.id, function(error, response) { if(utils.Request.isNotification(request)) { callback(); return; } callback(error, response); }); } // does the method exist? if(!(method instanceof jayson.Method)) { respond(self.error(Server.errors.METHOD_NOT_FOUND)); return; } // execute jayson.Method instance method.execute(self, request.params, context, function(error, result) { if(utils.Response.isValidError(error, self.options.version)) { respond(error); return; } // got an invalid error if(error) { respond(self.error(Server.errors.INTERNAL_ERROR)); return; } respond(null, result); }); }); }; /** * Invoke the router * @param {String} method Method to resolve * @param {Array|Object} params Request params * @return {Method} */ Server.prototype._resolveRouter = function(method, params) { let router = this.options.router; if(!_.isFunction(router)) { router = function(method) { return this.getMethod(method); }; } const resolved = router.call(this, method, params); // got a jayson.Method or a jayson.Client, return it if((resolved instanceof jayson.Method) || (resolved instanceof jayson.Client)) { return resolved; } // got a regular function, make it an instance of jayson.Method if(_.isFunction(resolved)) { return new jayson.Method(resolved); } }; /** * Evaluates a batch request * @private */ Server.prototype._batch = function(requests, context, callback) { const self = this; const responses = []; this.emit('batch', requests); /** * @ignore */ const maybeRespond = function() { // done when we have filled up all the responses with a truthy value const isDone = responses.every(function(response) { return response !== null; }); if(isDone) { // filters away notifications const filtered = responses.filter(function(res) { return res !== true; }); // only notifications in request means empty response if(!filtered.length) { return callback(); } callback(null, filtered); } }; /** * @ignore */ const wrapper = function(request, index) { responses[index] = null; return function() { if(utils.Request.isValidRequest(request, self.options.version)) { self.call(request, context, function(error, response) { responses[index] = error || response || true; maybeRespond(); }); } else { const error = self.error(Server.errors.INVALID_REQUEST); responses[index] = utils.response(error, undefined, undefined, self.options.version); maybeRespond(); } }; }; const stack = requests.map(function(request, index) { // ignore possibly nested requests if(utils.Request.isBatch(request)) { return null; } return wrapper(request, index); }); stack.forEach(function(method) { if(typeof(method) === 'function') { method(); } }); }; /** * Parse &quot;request&quot; if it is a string, else just invoke callback * @ignore */ function maybeParse(request, options, callback) { if(typeof(request) === 'string') { utils.JSON.parse(request, options, callback); } else { callback(null, request); } } × Search results Close "},"promise_lib_utils.js.html":{"id":"promise_lib_utils.js.html","title":"Source: promise/lib/utils.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: promise/lib/utils.js 'use strict'; const promisify = require('es6-promisify'); /** * @namespace */ const PromiseUtils = module.exports; /** * Wraps the client request method on an instance, making it return a promise in every case except when the fourth argument is explicitly set to false * @param {Function} request The original request method * @return {Function} */ PromiseUtils.wrapClientRequestMethod = function(request) { const promisified = promisify(request); return function(method, params, id, shouldCall) { if(shouldCall === false) { // this should return a raw request for use in batches return request(method, params, id); } return promisified.apply(this, arguments); }; }; × Search results Close "},"lib_server_http.js.html":{"id":"lib_server_http.js.html","title":"Source: lib/server/http.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/http.js 'use strict'; const http = require('http'); const utils = require('../utils'); /** * Constructor for a Jayson HTTP server * @class ServerHttp * @extends require('http').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerHttp} */ const HttpServer = function(server, options) { if(!(this instanceof HttpServer)) { return new HttpServer(server, options); } this.options = utils.merge(server.options, options || {}); const listener = utils.getHttpListener(this, server); http.Server.call(this, listener); }; require('util').inherits(HttpServer, http.Server); module.exports = HttpServer; × Search results Close "},"lib_server_https.js.html":{"id":"lib_server_https.js.html","title":"Source: lib/server/https.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/https.js 'use strict'; const https = require('https'); const utils = require('../utils'); /** * Constructor for a Jayson HTTPS server * @class ServerHttps * @extends require('https').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerHttps} */ const HttpsServer = function(server, options) { if(!(this instanceof HttpsServer)) { return new HttpsServer(server, options); } this.options = utils.merge(server.options, options || {}); const listener = utils.getHttpListener(this, server); https.Server.call(this, this.options, listener); }; require('util').inherits(HttpsServer, https.Server); module.exports = HttpsServer; × Search results Close "},"lib_server_middleware.js.html":{"id":"lib_server_middleware.js.html","title":"Source: lib/server/middleware.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/middleware.js 'use strict'; const utils = require('../utils'); /** * Creates a Connect/Express compatible middleware bound to a Server * @class ServerMiddleware * @param {Server} server Server instance * @param {Object} [outerOptions] Specific options for the middleware * @return {Function} */ const Middleware = function(server, outerOptions) { return function(req, res, next) { const options = utils.merge(server.options, outerOptions || {}); // default options.end to true if(typeof(options.end) !== 'boolean') { options.end = true; } // 405 method not allowed if not POST if(!utils.isMethod(req, 'POST')) { return error(405, { 'Allow': 'POST' }); } // 415 unsupported media type if Content-Type is not correct if(!utils.isContentType(req, 'application/json')) { return error(415); } // body does not appear to be parsed, 500 server error if(!req.body || typeof(req.body) !== 'object') { return next(new Error('Request body must be parsed')); } server.call(req.body, function(error, success) { const response = error || success; utils.JSON.stringify(response, options, function(err, body) { if(err) { return next(err); } // empty response? if(body) { const headers = { 'content-length': Buffer.byteLength(body, options.encoding), 'content-type': 'application/json; charset=utf-8' }; res.writeHead(200, headers); res.write(body); } else { res.writeHead(204); } // if end is false, next request instead of ending it if(options.end) { res.end(); } else { next(); } }); }); // ends the request with an error code function error(code, headers) { res.writeHead(code, headers || {}); res.end(); } }; }; module.exports = Middleware; × Search results Close "},"lib_server_tcp.js.html":{"id":"lib_server_tcp.js.html","title":"Source: lib/server/tcp.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/tcp.js 'use strict'; const net = require('net'); const utils = require('../utils'); /** * Constructor for a Jayson TCP server * @class ServerTcp * @extends require('net').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerTcp} */ const TcpServer = function(server, options) { if(!(this instanceof TcpServer)) { return new TcpServer(server, options); } this.options = utils.merge(server.options, options || {}); net.Server.call(this, getTcpListener(this, server)); }; require('util').inherits(TcpServer, net.Server); module.exports = TcpServer; /** * Returns a TCP connection listener bound to the server in the argument. * @param {Server} server Instance of JaysonServer * @param {net.Server} self Instance of net.Server * @return {Function} * @private * @ignore */ function getTcpListener(self, server) { return function(conn) { const options = self.options || {}; utils.parseStream(conn, options, function(err, request) { if(err) { return respondError(err); } server.call(request, function(error, success) { const response = error || success; if(response) { utils.JSON.stringify(response, options, function(err, body) { if(err) { return respondError(err); } conn.write(body); }); } else { // no response received at all, must be a notification } }); }); // ends the request with an error code function respondError(err) { const Server = require('../server'); const error = server.error(Server.errors.PARSE_ERROR, null, String(err)); const response = utils.response(error, undefined, undefined, self.options.version); utils.JSON.stringify(response, options, function(err, body) { if(err) { body = ''; // we tried our best. } conn.end(body); }); } }; } × Search results Close "},"lib_server_tls.js.html":{"id":"lib_server_tls.js.html","title":"Source: lib/server/tls.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/server/tls.js 'use strict'; const tls = require('tls'); const utils = require('../utils'); /** * Constructor for a Jayson TLS-encrypted TCP server * @class ServerTls * @extends require('tls').Server * @param {Server} server Server instance * @param {Object} [options] Options for this instance * @return {ServerTls} */ const TlsServer = function(server, options) { if(!(this instanceof TlsServer)) { return new TlsServer(server, options); } this.options = utils.merge(server.options, options || {}); tls.Server.call(this, this.options, getTlsListener(this, server)); }; require('util').inherits(TlsServer, tls.Server); module.exports = TlsServer; /** * Returns a TLS-encrypted TCP connection listener bound to the server in the argument. * @param {Server} server Instance of JaysonServer * @param {tls.Server} self Instance of tls.Server * @return {Function} * @private * @ignore */ function getTlsListener(self, server) { return function(conn) { const options = self.options || {}; utils.parseStream(conn, options, function(err, request) { if(err) { return respondError(err); } server.call(request, function(error, success) { const response = error || success; if(response) { utils.JSON.stringify(response, options, function(err, body) { if(err) { return respondError(err); } conn.write(body); }); } else { // no response received at all, must be a notification } }); }); // ends the request with an error code function respondError(err) { const Server = require('../server'); const error = server.error(Server.errors.PARSE_ERROR, null, String(err)); const response = utils.response(error, undefined, undefined, self.options.version); utils.JSON.stringify(response, options, function(err, body) { if(err) { body = ''; // we tried our best. } conn.end(body); }); } }; } × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Source: lib/utils.js 'use strict'; const _ = require('lodash'); const JSONStream = require('JSONStream'); const JSONstringify = require('json-stringify-safe'); const uuid = require('uuid/v4'); const generateRequest = require('./generateRequest'); /** * @namespace */ const Utils = module.exports; // same reference as other files use, for tidyness const utils = Utils; Utils.request = generateRequest; /** * Generates a JSON-RPC 1.0 or 2.0 response * @param {Object} error Error member * @param {Object} result Result member * @param {String|Number|null} id Id of request * @param {Number} version JSON-RPC version to use * @return {Object} A JSON-RPC 1.0 or 2.0 response */ Utils.response = function(error, result, id, version) { id = typeof(id) === 'undefined' || id === null ? null : id; error = typeof(error) === 'undefined' || error === null ? null : error; version = typeof(version) === 'undefined' || version === null ? 2 : version; const response = (version === 2) ? { jsonrpc: &quot;2.0&quot;, id: id } : { id: id }; // errors are always included in version 1 if(version === 1) { response.error = error; } // one or the other with precedence for errors if(error) { response.error = error; } else { response.result = result; } return response; }; /** * Generates a random UUID * @return {String} */ Utils.generateId = function() { return uuid(); }; /** * Merges properties of object b into object a * @param {...Object} Objects to be merged * @return {Object} * @private */ Utils.merge = function() { return _.extend.apply(null, arguments); }; /** * Parses an incoming stream for requests using JSONStream * @param {Stream} stream * @param {Object} options * @param {Function} onRequest - Called once for stream errors and an unlimited amount of times for valid requests */ Utils.parseStream = function(stream, options, onRequest) { const onError = _.once(onRequest); const onSuccess = _.partial(onRequest, null); const result = JSONStream.parse(); result.on('data', function(data) { // apply reviver walk function to prevent stringify/parse again if(_.isFunction(options.reviver)) { data = Utils.walk({'': data}, '', options.reviver); } onSuccess(data); }); result.on('error', onError); stream.on('error', onError); stream.pipe(result); }; /** * Helper to parse a stream and interpret it as JSON * @param {Stream} stream Stream instance * @param {Function} [reviver] Optional reviver for JSON.parse * @param {Function} callback */ Utils.parseBody = function(stream, options, callback) { callback = _.once(callback); let data = ''; stream.setEncoding('utf8'); stream.on('data', function(str) { data += str; }); stream.on('error', function(err) { callback(err); }); stream.on('end', function() { utils.JSON.parse(data, options, function(err, request) { if(err) { return callback(err); } callback(null, request); }); }); }; /** * Returns a HTTP request listener bound to the server in the argument. * @param {http.Server} self Instance of a HTTP server * @param {JaysonServer} server Instance of JaysonServer (typically jayson.Server) * @return {Function} * @private */ Utils.getHttpListener = function(self, server) { return function(req, res) { const options = self.options || {}; server.emit('http request', req); // 405 method not allowed if not POST if(!Utils.isMethod(req, 'POST')) { return respond('Method Not Allowed', 405, {'allow': 'POST'}); } // 415 unsupported media type if Content-Type is not correct if(!Utils.isContentType(req, 'application/json')) { return respond('Unsupported Media Type', 415); } Utils.parseBody(req, options, function(err, request) { if(err) { return respond(err, 400); } server.call(request, function(error, success) { const response = error || success; if(!response) { // no response received at all, must be a notification return respond('', 204); } utils.JSON.stringify(response, options, function(err, body) { if(err) { return respond(err, 500); } const headers = { 'content-length': Buffer.byteLength(body, options.encoding), 'content-type': 'application/json; charset=utf-8' }; respond(body, 200, headers); }); }); }); function respond(response, code, headers) { const body = response instanceof Error ? response.toString() : response; server.emit('http response', res, req); res.writeHead(code, headers || {}); res.end(body); } }; }; /** * Determines if a HTTP Request comes with a specific Content-Type * @param {ServerRequest} request * @param {String} type * @return {Boolean} * @private */ Utils.isContentType = function(request, type) { request = request || {headers: {}}; const contentType = request.headers['content-type'] || ''; return RegExp(type, 'i').test(contentType); }; /** * Determines if a HTTP Request is of a specific method * @param {ServerRequest} request * @param {String} method * @return {Boolean} * @private */ Utils.isMethod = function(request, method) { method = (method || '').toUpperCase(); return (request.method || '') === method; }; /** * Recursively walk an object and apply a function on its members * @param {Object} holder The object to walk * @param {String} key The key to look at * @param {Function} fn The function to apply to members * @return {Object} */ Utils.walk = function(holder, key, fn) { let k, v, value = holder[key]; if (value &amp;&amp; typeof value === 'object') { for (k in value) { if (Object.prototype.hasOwnProperty.call(value, k)) { v = Utils.walk(value, k, fn); if (v !== undefined) { value[k] = v; } else { delete value[k]; } } } } return fn.call(holder, key, value); }; /** * @namespace */ Utils.JSON = {}; /** * Parses a JSON string and then invokes the given callback * @param {String} str The string to parse * @param {Object} options Object with options, possibly holding a &quot;reviver&quot; function */ Utils.JSON.parse = function(str, options, callback) { let reviver = null; let obj = null; options = options || {}; if(_.isFunction(options.reviver)) { reviver = options.reviver; } try { obj = JSON.parse.apply(JSON, _.compact([str, reviver])); } catch(err) { return callback(err); } callback(null, obj); }; /** * Stringifies JSON and then invokes the given callback * @param {Object} obj The object to stringify * @param {Object} options Object with options, possibly holding a &quot;replacer&quot; function */ Utils.JSON.stringify = function(obj, options, callback) { let replacer = null; let str = null; options = options || {}; if(_.isFunction(options.replacer)) { replacer = options.replacer; } try { str = JSONstringify.apply(JSON, _.compact([obj, replacer])); } catch(err) { return callback(err); } callback(null, str); }; /** * @namespace */ Utils.Request = {}; /** * Determines if the passed request is a batch request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isBatch = function(request) { return Array.isArray(request); }; /** * Determines if the passed request is a notification request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isNotification = function(request) { return Boolean( request &amp;&amp; !Utils.Request.isBatch(request) &amp;&amp; (typeof(request.id) === 'undefined' || request.id === null) ); }; /** * Determines if the passed request is a valid JSON-RPC 2.0 Request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isValidVersionTwoRequest = function(request) { return Boolean( request &amp;&amp; typeof(request) === 'object' &amp;&amp; request.jsonrpc === '2.0' &amp;&amp; typeof(request.method) === 'string' &amp;&amp; ( typeof(request.params) === 'undefined' || Array.isArray(request.params) || (request.params &amp;&amp; typeof(request.params) === 'object') ) &amp;&amp; ( typeof(request.id) === 'undefined' || typeof(request.id) === 'string' || typeof(request.id) === 'number' || request.id === null ) ); }; /** * Determines if the passed request is a valid JSON-RPC 1.0 Request * @param {Object} request The request * @return {Boolean} */ Utils.Request.isValidVersionOneRequest = function(request) { return Boolean( request &amp;&amp; typeof(request) === 'object' &amp;&amp; typeof(request.method) === 'string' &amp;&amp; Array.isArray(request.params) &amp;&amp; typeof(request.id) !== 'undefined' ); }; /** * Determines if the passed request is a valid JSON-RPC Request * @param {Object} request The request * @param {Number} [version=2] JSON-RPC version 1 or 2 * @return {Boolean} */ Utils.Request.isValidRequest = function(request, version) { version = version === 1 ? 1 : 2; return Boolean( request &amp;&amp; ( (version === 1 &amp;&amp; Utils.Request.isValidVersionOneRequest(request)) || (version === 2 &amp;&amp; Utils.Request.isValidVersionTwoRequest(request)) ) ); }; /** * @namespace */ Utils.Response = {}; /** * Determines if the passed error is a valid JSON-RPC error response * @param {Object} error The error * @param {Number} [version=2] JSON-RPC version 1 or 2 * @return {Boolean} */ Utils.Response.isValidError = function(error, version) { version = version === 1 ? 1 : 2; return Boolean( version === 1 &amp;&amp; ( typeof(error) !== 'undefined' &amp;&amp; error !== null ) || version === 2 &amp;&amp; ( error &amp;&amp; typeof(error.code) === 'number' &amp;&amp; parseInt(error.code, 10) === error.code &amp;&amp; typeof(error.message) === 'string' ) ); }; /** * Determines if the passed object is a valid JSON-RPC response * @param {Object} response The response * @param {Number} [version=2] JSON-RPC version 1 or 2 * @return {Boolean} */ Utils.Response.isValidResponse = function(response, version) { version = version === 1 ? 1 : 2; return Boolean( response !== null &amp;&amp; typeof response === 'object' &amp;&amp; (version === 2 &amp;&amp; ( // check version response.jsonrpc === '2.0' &amp;&amp; ( // check id response.id === null || typeof response.id === 'string' || typeof response.id === 'number' ) &amp;&amp; ( // result and error do not exist at the same time (typeof response.result === 'undefined' &amp;&amp; typeof response.error !== 'undefined') || (typeof response.result !== 'undefined' &amp;&amp; typeof response.error === 'undefined') ) &amp;&amp; ( // check result (typeof response.result !== 'undefined') // check error object || ( response.error !== null &amp;&amp; typeof response.error === 'object' &amp;&amp; typeof response.error.code === 'number' // check error.code is integer &amp;&amp; ((response.error.code | 0) === response.error.code) &amp;&amp; typeof response.error.message === 'string' ) ) ) || version === 1 &amp;&amp; ( typeof response.id !== 'undefined' &amp;&amp; ( // result and error relation (the other null if one is not) (typeof response.result !== 'undefined' &amp;&amp; response.error === null) || (typeof response.error !== 'undefined' &amp;&amp; response.result === null) ) )) ); }; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Classes Classes Client ClientBrowser ClientHttp ClientHttps ClientTcp ClientTls Method Constructor for a Jayson Method PromiseClient PromiseClientHttp PromiseClientHttps PromiseClientTcp PromiseClientTls PromiseMethod PromiseServer Server ServerHttp ServerHttps ServerMiddleware ServerTcp ServerTls Namespaces Jayson JaysonPromise PromiseUtils Utils JSON Request Response × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespaces Classes Client ClientBrowser ClientHttp ClientHttps ClientTcp ClientTls Method Constructor for a Jayson Method PromiseClient PromiseClientHttp PromiseClientHttps PromiseClientTcp PromiseClientTls PromiseMethod PromiseServer Server ServerHttp ServerHttps ServerMiddleware ServerTcp ServerTls Namespaces Jayson JaysonPromise PromiseUtils Utils JSON Request Response × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls jayson 3.0.2 JaysonJayson is a JSON-RPC 2.0 and 1.0 compliant server and client written in JavaScript for node.js that aims to be as simple as possible to use. Table of contents Features Example Installation Changelog Requirements Class Documentation Running tests Typescript Usage Client Interface description Browser usage Notifications Batches Callback syntactic sugar Events Server Interface description Many interfaces at the same time Using the server as a relay Method routing Method definition Events Errors CORS Context Revivers and replacers Named parameters Promises Batches FAQ Recommended usage Contributing Features Servers that can listen to several interfaces at the same time Supports both HTTP and TCP client and server connections Server-side method routing Relaying of requests to other servers JSON reviving and replacing for transparent serialization of complex objects CLI client Promises Fully tested to comply with the official JSON-RPC 2.0 specification Also supports JSON-RPC 1.0 ExampleA basic JSON-RPC 2.0 server via HTTP: Server example in examples/simple_example/server.js: 'use strict'; const jayson = require('./../..'); // create a server const server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); server.http().listen(3000);Client example in examples/simple_example/client.js invoking add on the above server: 'use strict'; const jayson = require('./../..'); // create a client const client = jayson.client.http({ port: 3000 }); // invoke &quot;add&quot; client.request('add', [1, 1], function(err, response) { if(err) throw err; console.log(response.result); // 2 });InstallationInstall the latest version of jayson from npm by executing npm install jayson in your shell. Do a global install with npm install --global jayson if you want the jayson client CLI in your PATH. Changelog (only notable milestones) 3.0.0 Can pass a context object to handlers Breaking: collect option removed from jayson.Server/Method. JSON-RPC params to handlers are now always in the first argument. 2.1.0 Experimental typescript support 2.0.6 Clarified how to use in the browser 2.0.0 Added support for promises Breaking: collect: true is now the default option for a new jayson.Server and jayson.Method 1.2.0 Greatly improved server method definition 1.1.1 More http server events Remove fork server and client Add server routing 1.0.11 Add support for a HTTPS client 1.0.9 Add support for TCP servers and clients CLI clientThere is a basic CLI client in bin/jayson.js and it should be available as jayson in your shell if you installed the package globally. Run jayson --help to see how it works. RequirementsJayson does not have any special dependencies that cannot be resolved with a simple npm install. It is being continuously tested using travis-ci. You can look inside .travis.yml if you want to see which versions are tested against. Class documentationIn addition to this document, a comprehensive class documentation made with jsdoc is available at jayson.tedeh.net. Running tests Change directory to the repository root Install the development packages by executing npm install --dev Run the tests with npm run test TypescriptSince v2.1.0 there is experimental typescript support available with jayson. If you have a problem with the type definitions, see the Contributing section. UsageClientThe client is available as the Client or client property of require('jayson'). Client interface description Name Description Client Base class Client.tcp TCP interface Client.tls TLS interface Client.http HTTP interface Client.https HTTPS interface Client.browser Browser interface Every client supports these options: Option Default Type Description reviver undefined Function JSON.parse reviver replacer undefined Function JSON.stringify replacer generator RFC4122 generator Function Generates a String for request ID. version 2 Number JSON-RPC version to support (1 or 2) Client.httpUses the same options as http.request in addition to these options: Option Default Type Description encoding utf8 String Determines the encoding to use headers undefined Object Extend the headers sent by the client Client.http EventsThe HTTP server will emit the following events: Event When Arguments Notes http request Created an HTTP request 1. Instance of http.ClientRequest http response Received an HTTP response 1. Instance of http.IncomingMessage 2. Instance of http.ClientRequest http error Underlying stream emits error 1. Error http timeout Underlying stream emits timeout Automatically causes the request to abort It is possible to pass a string URL as the first argument. The URL will be run through url.parse. Example: var jayson = require('jayson'); var client = jayson.client.http('http://localhost:3000'); // client.options is now the result of url.parseClient.httpsUses the same options as https.request in addition to the same options as Client.http. This means it is also possible to pass a string URL as the first argument and have it interpreted by url.parse. Will emit the same custom events as Client.http. Client.tcpUses the same options as net.connect in addition to the same options as Client.http. Client.tlsUses the same options as tls.connect in addition to the same options as Client.http. Client.browserThe browser client is a simplified version of the regular client for use browser-side. It does not have any dependencies on node.js core libraries (but does depend on the uuid and lodash) and also does not know how to &quot;send&quot; a request to a server like the other clients. Because it does not depend on any core libraries, the browser client is not an instance of JaysonClient or EventEmitter and therefore does not emit any of the normal request events that the other clients do. To use the browser client, require('jayson/lib/client/browser') and pass a calling/transport function as the first argument. The transport function receives a JSON-RPC string request and is expected to callback with a string response received from the server (not JSON) or an error (not a JSON-RPC error). The reason for dealing with strings is to support the reviver and replacer options like the other clients. This client example in examples/browser_client/client.js below uses node-fetch in the transport function, but a dropin replacement for use in an actual browser could instead use whatwg-fetch. 'use strict'; const jaysonBrowserClient = require('./../../lib/client/browser'); const fetch = require('node-fetch'); const callServer = function(request, callback) { const options = { method: 'POST', body: request, headers: { 'Content-Type': 'application/json', } }; fetch('http://localhost:3000', options) .then(function(res) { return res.text(); }) .then(function(text) { callback(null, text); }) .catch(function(err) { callback(err); }); }; const client = jaysonBrowserClient(callServer, { // other options go here }); client.request('multiply', [5, 5], function(err, error, result) { if(err) throw err; console.log(result); // 25 });NotificationsNotification requests are for cases where the reply from the server is not important and should be ignored. This is accomplished by setting the id property of a request object to null. Client example in examples/notifications/client.js doing a notification request: 'use strict'; const jayson = require('./../..'); const client = jayson.client.http({ port: 3000 }); // the third parameter is set to &quot;null&quot; to indicate a notification client.request('ping', [], null, function(err) { if(err) throw err; console.log('ok'); // request was received successfully });Server example in examples/notifications/server.js: 'use strict'; const jayson = require('./../..'); const server = jayson.server({ ping: function(args, callback) { // do something, do nothing callback(); } }); server.http().listen(3000);Notes Any value that the server returns will be discarded when doing a notification request. Omitting the third argument null to Client.prototype.request does not generate a notification request. This argument has to be set explicitly to null for this to happen. Network errors and the like will still reach the callback. When the callback is invoked (with or without error) one can be certain that the server has received the request. See the Official JSON-RPC 2.0 Specification for additional information on how Jayson handles notifications that are erroneous. BatchesA batch request is an array of individual requests that are sent to the server as one. Doing a batch request is very simple in Jayson and consists of constructing an array of individual requests (created by not passing a callback to Client.prototype.request) that is then itself passed to Client.prototype.request. Combined server/client example in examples/batch_request/index.js: 'use strict'; const jayson = require('./../..'); const server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); const client = jayson.client(server); const batch = [ client.request('does_not_exist', [10, 5]), client.request('add', [1, 1]), client.request('add', [0, 0], null) // a notification ]; client.request(batch, function(err, errors, successes) { if(err) throw err; console.log('errors', errors); // array of requests that errored console.log('successes', successes); // array of requests that succeeded }); client.request(batch, function(err, responses) { if(err) throw err; console.log('responses', responses); // all responses together });Notes See the Official JSON-RPC 2.0 Specification for additional information on how Jayson handles different types of batches, mainly with regards to notifications, request errors and so forth. There is no guarantee that the results will be in the same order as request Array request. To find the right result, compare the ID from the request with the ID in the result yourself. Client callback syntactic sugarWhen the length (number of arguments) of a client callback function is either 2 or 3 it receives slightly different values when invoked. 2 arguments: first argument is an error or null, second argument is the response object as returned (containing either a result or a error property) or null for notifications. 3 arguments: first argument is an error or null, second argument is a JSON-RPC error property or null (if success), third argument is a JSON-RPC result property or null (if error). When doing a batch request with a 3-length callback, the second argument will be an array of requests with a error property and the third argument will be an array of requests with a result property. Client eventsA client will emit the following events (in addition to any special ones emitted by a specific interface): Event When Arguments Notes request About to dispatch a request 1: Request object response Received a response 1: Request object 2: Response object received ServerThe server classes are available as the Server or server property of require('jayson'). The server also sports several interfaces that can be accessed as properties of an instance of Server. Server interface description Name Description Server Base interface for a server that supports receiving JSON-RPC requests Server.tcp TCP server that inherits from net.Server Server.tls TLS server that inherits from tls.Server Server.http HTTP server that inherits from http.Server Server.https HTTPS server that inherits from https.Server Server.middleware Method that returns a Connect/Express compatible middleware function Servers supports these options: Option Default Type Description reviver null Function JSON.parse reviver replacer null Function JSON.stringify replacer router null Function Return the function for method routing useContext false Boolean Passed to methodConstructor options params undefined Array/Object/null Passed to methodConstructor options methodConstructor jayson.Method Function Server functions are made an instance of this class version 2 Number JSON-RPC version to support (1 or 2) Server.tcpUses the same options as the base class. Inherits from net.Server. Server.tlsUses the same options as the base class. Inherits from tls.Server. Server.httpUses the same options as the base class. Inherits from http.Server. Server.http Events Event When Arguments Notes http request Incoming HTTP request 1. Instance of http.IncomingMessage http response About to send a HTTP response 1. Instance of http.ServerResponse 2. Instance of http. IncomingMessage Server.httpsUses the same options as the base class. Inherits from https.Server and jayson.Server.http. For information on how to configure certificates, see the documentation on https.Server. Will emit the same custom events as Server.http. Server.middlewareUses the same options as the base class. Returns a function that is compatible with Connect or Express. Will expect the request to be req.body, meaning that the request body must be parsed (typically using connect.bodyParser) before the middleware is invoked. The middleware supports the following options: Option Default Type Description end true Boolean If set to false causes the middleware to next() instead of res.end() when finished. Middleware example in examples/middleware/server.js: 'use strict'; const jayson = require('./../..'); const jsonParser = require('body-parser').json; const connect = require('connect'); const app = connect(); const server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); // parse request body before the jayson middleware app.use(jsonParser()); app.use(server.middleware()); app.listen(3000);Many interfaces at the same timeA Jayson server can use many interfaces at the same time. Server example in examples/many_interfaces/server.js that listens to both http and a https requests: 'use strict'; const jayson = require('./../..'); const server = jayson.server(); // &quot;http&quot; will be an instance of require('http').Server const http = server.http(); // &quot;https&quot; will be an instance of require('https').Server const https = server.https({ //cert: require('fs').readFileSync('cert.pem'), //key require('fs').readFileSync('key.pem') }); http.listen(80, function() { console.log('Listening on *:80'); }); https.listen(443, function() { console.log('Listening on *:443'); });Using the server as a relayPassing an instance of a client as a method to the server makes the server relay incoming requests to wherever the client is pointing to. This might be used to delegate computationally expensive functions into a separate server or to abstract a cluster of servers behind a common interface. Frontend server example in examples/relay/server_public.js listening on *:3000: 'use strict'; const jayson = require('./../..'); // create a server where &quot;add&quot; will relay a localhost-only server const server = jayson.server({ add: jayson.client.http({ port: 3001 }) }); // let the frontend server listen to *:3000 server.http().listen(3000);Backend server example in examples/relay/server_private.js listening on *:3001: 'use strict'; const jayson = require('./../..'); const server = jayson.server({ add: function(args, callback) { callback(null, args[0] + args[1]); } }); // let the backend listen to *:3001 server.http().listen(3001);Every request to add on the public server will now relay the request to the private server. See the client example in examples/relay/client.js. Method routingPassing a property named router in the server options will enable you to write your own logic for routing requests to specific functions. Server example with custom routing logic in examples/method_routing/server.js: 'use strict'; const jayson = require('./../..'); const methods = { add: function(args, callback) { callback(null, args[0] + args[1]); } }; const server = jayson.server(methods, { router: function(method, params) { // regular by-name routing first if(typeof(this._methods[method]) === 'function') return this._methods[method]; if(method === 'add_2') { const fn = server.getMethod('add').getHandler(); return new jayson.Method(function(args, done) { args.unshift(2); fn(args, done); }); } } }); server.http().listen(3000);Client example in examples/method_routing/client.js invoking add_2 on the above server: 'use strict'; const jayson = require('./../..'); // create a client const client = jayson.client.http({ port: 3000 }); // invoke &quot;add_2&quot; client.request('add_2', [3], function(err, response) { if(err) throw err; console.log(response.result); // 5! });Server example of nested routes where each property is separated by a dot (you do not need to use the router option for this): 'use strict'; const _ = require('lodash'); const jayson = require('jayson'); const methods = { foo: { bar: function(callback) { callback(null, 'ping pong'); } }, math: { add: function(args, callback) { callback(null, args[0] + args[1]); } } }; // this reduction produces an object like this: {'foo.bar': [Function], 'math.add': [Function]} const map = _.reduce(methods, collapse('', '.'), {}); const server = jayson.server(map); function collapse(stem, sep) { return function(map, value, key) { var prop = stem ? stem + sep + key : key; if(_.isFunction(value)) map[prop] = value; else if(_.isObject(value)) map = _.reduce(value, collapse(prop, sep), map); return map; } }Notes If router does not return anything, the server will respond with a Method Not Found error. The Server.prototype methods method, methods, removeMethod and hasMethod will not use the router method, but will operate on the internal Server.prototype._methods map. The router method is expected to return instances of jayson.Method (&gt;=1.2.0) Method definitionYou can also define server methods inside a wrapping object named jayson.Method. This allows additional options about the method to be specified. Using this wrapper - explicitly or implicitly (via server options) - makes it trivial to have your method accept a variable amount of arguments. The method class is available as the Method or method property of require('jayson'). It supports these options: Option Default Type Description handler Function The actual function that will handle a JSON-RPC request to this method useContext false Boolean When true, the handler will receive a context object as the second argument params null `Array Object null` Force JSON-RPC parameters to be of a certain type Server example showcasing most features and options in examples/method_definitions/server.js: 'use strict'; const jayson = require('./../..'); const _ = require('lodash'); const methods = { // this function will be wrapped in jayson.Method with options given to the server sum: function(args, done) { done(null, sum(args)); }, // this function always receives a context object as second arg // it can be overriden on the server level context: jayson.Method(function(args, context, done) { done(null, context); }, {useContext: true}), // specifies some default values (alternate definition too) sumDefault: jayson.Method(function(args, done) { const total = sum(args); done(null, total); }, { params: {a: 2, b: 5} // map of defaults }), // this method returns true when it gets an array (which it always does) isArray: new jayson.Method({ handler: function(args, done) { const result = _.isArray(args); done(null, result); }, params: Array // could also be &quot;Object&quot; }) }; const server = jayson.server(methods, { // these options are given as options to jayson.Method when adding the method &quot;sum&quot;. // this is because it is not wrapped in jayson.Method like the others. useContext: false, params: Array }); server.http().listen(3000); // sums all numbers in an array or object function sum(list) { return _.reduce(list, function(sum, val) { return sum + val; }, 0); }Client example in examples/method_definitions/client.js: 'use strict'; const jayson = require('./../..'); const client = jayson.client.http({ port: 3000 }); // invoke &quot;sum&quot; with array client.request('sum', [3, 5, 9, 11], function(err, response) { if(err) throw err; console.log(response.result); // 28 }); // invoke &quot;sum&quot; with an object client.request('sum', {a: 2, b: 3, c: 4}, function(err, response) { if(err) throw err; console.log(response.result); // 9 }); // invoke &quot;sumDefault&quot; with object missing some defined members client.request('sumDefault', {b: 10}, function(err, response) { if(err) throw err; console.log(response.result); // 12 }); // invoke &quot;isArray&quot; with an Object client.request('isArray', {a: 5, b: 2, c: 9}, function(err, response) { if(err) throw err; console.log(response.result); // true }); // invoke &quot;context&quot; client.request('context', {hello: 'world'}, function(err, response) { if(err) throw err; console.log(response.result); // {} - just an empty object });Server eventsIn addition to events that are specific to certain interfaces, all servers will emit the following events: Event When Arguments Notes request Interpretable non-batch request received 1: Request object response Returning a response 1: Request object 2: Response object batch Interpretable batch request received 1. Array of requests Emits request for every part Server ErrorsIf you should like to return an error from an method request to indicate a failure, remember that the JSON-RPC 2.0 specification requires the error to be an Object with a code (Integer/Number) to be regarded as valid. You can also provide a message (String) and a data (Object) with additional information. Example: var jayson = require('jayson'); var server = jayson.server({ i_cant_find_anything: function(args, callback) { var error = {code: 404, message: 'Cannot find ' + args.id}; callback(error); // will return the error object as given }, i_cant_return_a_valid_error: function(callback) { callback({message: 'I forgot to enter a code'}); // will return a pre-defined &quot;Internal Error&quot; } });Predefined ErrorsIt is also possible to cause a method to return one of the predefined JSON-RPC 2.0 error codes using the server helper function Server.prototype.error inside of a server method. Example: var jayson = require('jayson'); var server = jayson.server({ invalid_params: function(args, callback) { var error = this.error(-32602); // returns an error with the default properties set callback(error); } });You can even override the default messages: var jayson = require('jayson'); var server = jayson.server({ error_giver_of_doom: function(callback) { callback(true) // invalid error format, which causes an Internal Error to be returned instead } }); // Override the default message server.errorMessages[Server.errors.INTERNAL_ERROR] = 'I has a sad. I cant do anything right';Server CORSJayson does not include functionality for supporting CORS requests natively but it is easy to use a CORS-enabling middleware like cors. An example of this can be found in examples/cors/server.js: 'use strict'; const jayson = require('./../..'); const cors = require('cors'); const connect = require('connect'); const jsonParser = require('body-parser').json; const app = connect(); const server = jayson.server({ myNameIs: function(args, callback) { callback(null, 'Your name is: ' + args.name); } }); app.use(cors({methods: ['POST']})); app.use(jsonParser()); app.use(server.middleware()); app.listen(3000);Server ContextSince version 3.0.0 You can provide an optional context object to JSON-RPC method handlers. This can be used to give extra data to a handler such as request headers, authentication tokens, and so on. This feature is unlocked by having jayson.Method accepts a boolean option called useContext. It always defaults to false for backwards compatibility. When it is set to true the method handler that jayson.Method wraps will always receive a context object as the second argument. The object can be given as the third argument to jayson.Server.prototype.call. Server example in examples/context/server.js: 'use strict'; const _ = require('lodash'); const jayson = require('./../..'); const jsonParser = require('body-parser').json; const express = require('express'); const app = express(); const server = jayson.server({ getHeaders: function(args, context, callback) { callback(null, context.headers); }, // old method not receiving a context object (here for reference) oldMethod: new jayson.Method(function(args, callback) { callback(null, {}); }, { // this setting overrides the server option set below for this particular method only useContext: false }) }, { // all methods will receive a context object as the second arg useContext: true }); app.use(jsonParser()); app.use(function(req, res, next) { // prepare a context object passed into the JSON-RPC method const context = {headers: req.headers}; server.call(req.body, context, function(err, result) { if(err) return next(err); res.send(result || {}); }); }); app.listen(3001);Client example in examples/context/client.js: 'use strict'; const jayson = require('./../..'); // create a client const client = jayson.client.http({ port: 3001 }); // invoke &quot;getHeaders&quot; client.request('getHeaders', {}, function(err, response) { if(err) throw err; console.log(response.result); });Notes jayson.Server also accepts useContext as an option, and passes the value on to the jayson.Method constructor. This option can be overriden on a per-method basis as shown above. Individual requests in a JSON-RPC batch will all receive the exact same context object in their handler - take care not to mutate it If a falsy context value is given to jayson.Server.prototype.call, an empty object will be created None of the current jayson server transports (http, https, tls, tcp, middleware) can make use of the context object. You will need to rig your own transport implementation, like the one above based on an express http server. See the FAQ for more info about this. Revivers and ReplacersJSON lacks support for representing types other than the simple ones defined in the JSON specification. Fortunately the JSON methods in JavaScript (JSON.parse and JSON.stringify) provide options for custom serialization/deserialization routines. Jayson allows you to pass your own routines as options to both clients and servers. Simple example transferring the state of an object between a client and a server: Shared code between the server and the client in examples/reviving_and_replacing/shared.js: 'use strict'; const Counter = exports.Counter = function(value) { this.count = value || 0; }; Counter.prototype.increment = function() { this.count += 1; }; exports.replacer = function(key, value) { if(value instanceof Counter) { return {$class: 'counter', $props: {count: value.count}}; } return value; }; exports.reviver = function(key, value) { if(value &amp;&amp; value.$class === 'counter') { const obj = new Counter(); for(const prop in value.$props) obj[prop] = value.$props[prop]; return obj; } return value; };Server example in examples/reviving_and_replacing/server.js: 'use strict'; const jayson = require('./../..'); const shared = require('./shared'); // Set the reviver/replacer options const options = { reviver: shared.reviver, replacer: shared.replacer }; // create a server const server = jayson.server({ increment: function(args, callback) { args.counter.increment(); callback(null, args.counter); } }, options); server.http().listen(3000);A client example in examples/reviving_and_replacing/client.js invoking &quot;increment&quot; on the server: 'use strict'; const jayson = require('./../..'); const shared = require('./shared'); const client = jayson.client.http({ port: 3000, reviver: shared.reviver, replacer: shared.replacer }); // create the object const params = { counter: new shared.Counter(2) }; // invoke &quot;increment&quot; client.request('increment', params, function(err, response) { if(err) throw err; const result = response.result; console.log( result instanceof shared.Counter, // true result.count, // 3 params.counter === result // false - result is a new object ); });Notes Instead of using a replacer, it is possible to define a toJSON method for any JavaScript object. Unfortunately there is no corresponding method for reviving objects (that would not work, obviously), so the reviver always has to be set up manually. Named parametersIt is possible to specify named parameters when doing a client request by passing an Object instead of an Array. Client example in examples/named_parameters/client.js: 'use strict'; const jayson = require('jayson'); const client = jayson.client.http({ port: 3000 }); client.request('add', {b: 1, a: 2}, function(err, response) { if(err) throw err; console.log(response.result); // 3! });Server example in examples/named_parameters/server.js: 'use strict'; const jayson = require('./../..'); const server = jayson.server({ add: function(params, callback) { callback(null, params.a + params.b); } }); server.http().listen(3000);Notes If requesting methods on a Jayson server, arguments left out will be undefined Too many arguments or arguments with invalid names will be ignored It is assumed that the last argument to a server method is the callback and it will not be filled with something else Parsing a function signature and filling in arguments is generally not recommended and should be avoided PromisesSince version 2.0.0 A separate tree that does limited usage of the ES6 Promise object is available. The internal API remains callback based, with the addition that promises may be used for two things: Returning a Promise when requesting a JSON-RPC method using a Client Returning a Promise inside of a Server method To use the separate tree, do a require('jayson/promise') instead of require('jayson'). Server example in examples/promise/server.js showing how to return a Promise in a server method: 'use strict'; const jayson = require('../../promise'); const _ = require('lodash'); const server = jayson.server({ add: function(args) { return new Promise(function(resolve, reject) { const sum = _.reduce(args, function(sum, value) { return sum + value; }, 0); resolve(sum); }); }, // example on how to reject rejection: function(args) { return new Promise(function(resolve, reject) { // server.error just returns {code: 501, message: 'not implemented'} reject(server.error(501, 'not implemented')); }); } }); server.http().listen(3000);Client example in examples/promise/client.js showing how to do a request: 'use strict'; const jayson = require('../../promise'); const client = jayson.client.http({ port: 3000 }); const reqs = [ client.request('add', [1, 2, 3, 4, 5]), client.request('rejection', []) ]; Promise.all(reqs).then(function(responses) { console.log(responses[0].result); console.log(responses[1].error); });Notes JSON-RPC errors will not result in rejection of the Promise. It is however possible that a future version will include a client setting to have JSON-RPC errors result in rejection. Please note that network errors and the like will result in rejection. A Promise is considered to have been returned from a server method if the returned object has a property then that is a function. Promise BatchesSince version 2.0.5 Sometimes you may want to return raw requests from a promise client. This needs to be handled differently, because PromiseClient.prototype.request would normally always be expected to return a Promise which we in this case don't want. To solve this, we need to set the fourth parameter to PromiseClient.prototype.request explicitly to false in order to not return a Promise. Client example in examples/promise_batches/client.js showing how to properly execute a batch request: 'use strict'; const jayson = require('../../promise'); const client = jayson.client.http({ port: 3000 }); const batch = [ client.request('add', [1, 2, 3, 4, 5], undefined, false), client.request('add', [5, 6, 7, 8, 9], undefined, false), ]; client.request(batch).then(function(responses) { console.log(responses[0].result); // 15 console.log(responses[1].result); // 35 });Notes The third parameter to PromiseClient.prototype.request above is explicitly set to undefined - this parameter would normally represent the desired ID of the call. Remember that null would mean a notification (which does not return a response) and other falsy values may actually be used as ids. Setting undefined ensures that the id is generated automatically. FAQHow can I pass HTTP headers/session/etc into my JSON-RPC request handler?Support for method context added in version 3.0.0 See Server context section. What is the recommended way to use jayson?Using the provided clients and servers for http, https, tls, tcp and the express middleware is fine and works well for most use cases. However, sometimes issues like these crop up (quotes below are not directly from issue posters): &quot;The (non-jayson) HTTP/TCP server I'm interacting with expects every call to terminate with \\r\\n but the jayson client does not&quot; &quot;How can my jayson TLS server support requests encoded such and such?&quot; &quot;How can I make the jayson HTTP middleware accept GET requests?&quot; &quot;My jayson client interacting with a (non-jayson) TLS server closes the connection after every sent request. I think this is wasteful!&quot; These are not issues with jayson, but stem from the fact that JSON-RPC 2.0 specification is transport agnostic and these kind of behaviours are not defined by that specification. The clients provided by jayson for http, https, tls, tcp are made to work and tested with their corresponding jayson server implementation. Any other compatibility with any other server or client is accidental when it comes to details of the transport layer. With that said, jayson is made to be 100 % compatible with the JSON-RPC 2.0 specification and compatibility with other non-jayson servers or clients when it comes to the application layer is pretty much guaranteed. The library author tedeh therefore recommends that if you have particular needs when it comes to the transport layer you create an implementation satisfying these details yourself. Doing this is actually quite simple. Example of a http server built with express in examples/faq_recommended_http_server/server.js: 'use strict'; const _ = require('lodash'); const jayson = require('./../..'); const jsonParser = require('body-parser').json; const express = require('express'); const app = express(); // create a plain jayson server const server = jayson.server({ add: function(numbers, callback) { callback(null, _.reduce(numbers, (sum, val) =&gt; sum + val, 0)); } }); app.use(jsonParser()); // &lt;- here we can deal with maximum body sizes, etc app.use(function(req, res, next) { const request = req.body; // &lt;- here we can check headers, modify the request, do logging, etc server.call(request, function(err, response) { if(err) { // if err is an Error, err is NOT a json-rpc error if(err instanceof Error) return next(err); // &lt;- deal with json-rpc errors here, typically caused by the user res.status(400); res.send(err); return; } // &lt;- here we can mutate the response, set response headers, etc if(response) { res.send(response); } else { // empty response (could be a notification) res.status(204); res.send(''); } }); }); app.listen(3001);Using some of the utilities provided and exported by jayson, creating a client offering the same kind of flexibility is also simple. Example of a compatible http client built with superagent in examples/faq_recommended_http_server/client.js: 'use strict'; const jayson = require('./../..'); const request = require('superagent'); // generate a json-rpc version 2 compatible request (non-notification) const requestBody = jayson.Utils.request('add', [1,2,3,4], undefined, { version: 2, // generate a version 2 request }); request.post('http://localhost:3001') // &lt;- here we can setup timeouts, set headers, cookies, etc .timeout({response: 5000, deadline: 60000}) .send(requestBody) .end(function(err, response) { if(err) { // superagent considers 300-499 status codes to be errors // @see http://visionmedia.github.io/superagent/#error-handling if(!err.status) throw err; const body = err.response.body; // body may be a JSON-RPC error, or something completely different // it can be handled here if(body &amp;&amp; body.error &amp;&amp; jayson.Utils.Response.isValidError(body.error, 2)) { // the error body was a valid JSON-RPC version 2 // we may wish to deal with it differently console.err(body.error); return; } throw err; // error was something completely different } const body = response.body; // check if we got a valid JSON-RPC 2.0 response if(!jayson.Utils.Response.isValidResponse(body, 2)) { console.err(body); } if(body.error) { // we have a json-rpc error... console.err(body.error); // 10! } else { // do something useful with the result console.log(body.result); // 10! } });ContributingHighlighting issues or submitting pull requests on Github is most welcome. Please make sure to follow the style of the project, and lint your code with npm run lint before submitting a patch. Submitting issues with the Typescript type definitionsYou are required to provide an easily reproducible code sample of any errors with the Typescript type definitions so that they can be added to the typescript test file in typescript/test.ts. Better yet, issue a pull request adding a test there yourself that shows up when running the package.json script test-tsc. × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: Client Client new Client( [server] [, options]) Constructor for a Jayson Client Parameters: Name Type Argument Description server Server &lt;optional&gt; An instance of Server (a object with a &quot;call&quot; method&quot;) options Object &lt;optional&gt; Properties Name Type Argument Default Description reviver function &lt;optional&gt; Reviver function for JSON replacer function &lt;optional&gt; Replacer function for JSON version Number &lt;optional&gt; 2 JSON-RPC version to use (1|2) generator function &lt;optional&gt; Function to use for generating request IDs Source: lib/client/index.js, line 7 Returns: Type Client Extends require('events').EventEmitter Members &lt;static&gt; browser :ClientBrowser Browser client constructor Type: ClientBrowser Source: lib/client/index.js, line 79 &lt;static&gt; http :ClientHttp HTTP client constructor Type: ClientHttp Source: lib/client/index.js, line 51 &lt;static&gt; https :ClientHttps HTTPS client constructor Type: ClientHttps Source: lib/client/index.js, line 58 &lt;static&gt; tcp :ClientTcp TCP client constructor Type: ClientTcp Source: lib/client/index.js, line 65 &lt;static&gt; tls :ClientTls TLS client constructor Type: ClientTls Source: lib/client/index.js, line 72 Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientBrowser.html":{"id":"ClientBrowser.html","title":"Class: ClientBrowser","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientBrowser ClientBrowser new ClientBrowser(callServer [, options]) Constructor for a Jayson Browser Client that does not depend any node.js core libraries Parameters: Name Type Argument Description callServer function Method that calls the server, receives the stringified request and a regular node-style callback options Object &lt;optional&gt; Properties Name Type Argument Default Description reviver function &lt;optional&gt; Reviver function for JSON replacer function &lt;optional&gt; Replacer function for JSON version Number &lt;optional&gt; 2 JSON-RPC version to use (1|2) generator function &lt;optional&gt; Function to use for generating request IDs Source: lib/client/browser.js, line 12 Returns: Type ClientBrowser Methods request(method [, params] [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object &lt;optional&gt; Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Source: lib/client/browser.js, line 50 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientHttp.html":{"id":"ClientHttp.html","title":"Class: ClientHttp","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientHttp ClientHttp ClientHttp new ClientHttp( [options]) Constructor for a Jayson HTTP Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; String interpreted as a URL Properties Name Type Argument Default Description encoding String &lt;optional&gt; &quot;utf8&quot; Encoding to use Source: lib/client/http.js, line 17 Returns: Type ClientHttp Extends Client Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientHttps.html":{"id":"ClientHttps.html","title":"Class: ClientHttps","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientHttps ClientHttps ClientHttps new ClientHttps( [options]) Constructor for a Jayson HTTPS Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; String interpreted as a URL Properties Name Type Argument Default Description encoding String &lt;optional&gt; &quot;utf8&quot; Encoding to use Source: lib/client/https.js, line 15 Returns: Type ClientHttps Extends ClientHttp Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientTcp.html":{"id":"ClientTcp.html","title":"Class: ClientTcp","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientTcp ClientTcp ClientTcp new ClientTcp( [options]) Constructor for a Jayson TCP Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; Optional hash of settings or a URL Source: lib/client/tcp.js, line 16 Returns: Type ClientTcp Extends Client Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"ClientTls.html":{"id":"ClientTls.html","title":"Class: ClientTls","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ClientTls ClientTls ClientTls new ClientTls( [options]) Constructor for a Jayson TLS-encrypted TCP Client Parameters: Name Type Argument Description options Object | String &lt;optional&gt; Optional hash of settings or a URL Source: lib/client/tls.js, line 16 Returns: Type ClientTls Extends Client Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"Jayson.html":{"id":"Jayson.html","title":"Namespace: Jayson","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Jayson Jayson Namespace available as require('jayson') Source: lib/index.js, line 3 Members &lt;static&gt; Client :Client Type: Client Source: lib/index.js, line 13 &lt;static&gt; Method :Method Type: Method Source: lib/index.js, line 31 &lt;static&gt; Server :Server Type: Server Source: lib/index.js, line 19 &lt;static&gt; Utils :Utils Type: Utils Source: lib/index.js, line 25 × Search results Close "},"JaysonPromise.html":{"id":"JaysonPromise.html","title":"Namespace: JaysonPromise","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: JaysonPromise JaysonPromise Namespace available as require('jayson/promise') Source: promise/lib/index.js, line 5 Members &lt;static&gt; Client :PromiseClient Type: PromiseClient Source: promise/lib/index.js, line 15 &lt;static&gt; Method :PromiseMethod Type: PromiseMethod Source: promise/lib/index.js, line 33 &lt;static&gt; Server :Server Type: Server Source: promise/lib/index.js, line 21 &lt;static&gt; Utils :Utils Type: Utils Source: promise/lib/index.js, line 27 × Search results Close "},"Method.html":{"id":"Method.html","title":"Class: Method","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: Method Method new Method( [handler] [, options]) Constructor for a Jayson Method Parameters: Name Type Argument Description handler function &lt;optional&gt; Function to set as handler options Object &lt;optional&gt; Properties Name Type Argument Default Description handler function &lt;optional&gt; Same as separate handler useContext Boolean &lt;optional&gt; false When true, the handler expects a context object params Array | Object &lt;optional&gt; Defines params that the handler accepts Source: lib/method.js, line 6 Methods execute(server, requestParams [, context], callback) Executes this method in the context of a server Parameters: Name Type Argument Description server Server requestParams Array | Object context Object &lt;optional&gt; callback function Source: lib/method.js, line 103 getHandler() Returns the handler function associated with this method Source: lib/method.js, line 43 Returns: Type function setHandler(handler) Sets the handler function associated with this method Parameters: Name Type Description handler function Source: lib/method.js, line 51 × Search results Close "},"PromiseClient.html":{"id":"PromiseClient.html","title":"Class: PromiseClient","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClient PromiseClient new PromiseClient() Constructor for a Jayson Promise Client Source: promise/lib/client/index.js, line 7 See: Client Returns: Type PromiseClient Extends Client Members &lt;static&gt; http :PromiseClientHttp Type: PromiseClientHttp Source: promise/lib/client/index.js, line 27 &lt;static&gt; https :PromiseClientHttps Type: PromiseClientHttps Source: promise/lib/client/index.js, line 33 &lt;static&gt; tcp :PromiseClientTcp Type: PromiseClientTcp Source: promise/lib/client/index.js, line 45 &lt;static&gt; tls :PromiseClientTls Type: PromiseClientTls Source: promise/lib/client/index.js, line 40 Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientHttp.html":{"id":"PromiseClientHttp.html","title":"Class: PromiseClientHttp","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientHttp PromiseClientHttp new PromiseClientHttp() Constructor for a Jayson Promise Client Http Source: promise/lib/client/http.js, line 7 See: Client Returns: Type PromiseClientHttp Extends ClientHttp Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientHttps.html":{"id":"PromiseClientHttps.html","title":"Class: PromiseClientHttps","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientHttps PromiseClientHttps new PromiseClientHttps() Constructor for a Jayson Promise Client Http Source: promise/lib/client/https.js, line 7 See: Client Returns: Type PromiseClientHttps Extends ClientHttps Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientTcp.html":{"id":"PromiseClientTcp.html","title":"Class: PromiseClientTcp","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientTcp PromiseClientTcp new PromiseClientTcp() Constructor for a Jayson Promise Client Tcp Source: promise/lib/client/tcp.js, line 7 See: Client Returns: Type PromiseClientTcp Extends ClientTcp Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseClientTls.html":{"id":"PromiseClientTls.html","title":"Class: PromiseClientTls","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseClientTls PromiseClientTls new PromiseClientTls() Constructor for a Jayson Promise Client Tls Source: promise/lib/client/tls.js, line 7 See: Client Returns: Type PromiseClientTls Extends ClientTls Methods request(method, params [, id] [, callback]) Creates a request and dispatches it if given a callback. Parameters: Name Type Argument Description method String | Array A batch request if passed an Array, or a method name if passed a String params Array | Object Parameters for the method id String | Number &lt;optional&gt; Optional id. If undefined an id will be generated. If null it creates a notification request callback function &lt;optional&gt; Request callback. If specified, executes the request rather than only returning it. Inherited From: Client#request Source: lib/client/index.js, line 90 Throws: Invalid parameters Type TypeError Returns: JSON-RPC 1.0 or 2.0 compatible request Type Object × Search results Close "},"PromiseMethod.html":{"id":"PromiseMethod.html","title":"Class: PromiseMethod","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseMethod PromiseMethod new PromiseMethod() Constructor for a Jayson Promise Method Source: promise/lib/method.js, line 6 See: Method Returns: Type PromiseMethod Extends Method Methods execute(server, requestParams, outerCallback) Executes this method in the context of a server Parameters: Name Type Description server Server requestParams Array | Object outerCallback function Overrides: Method#execute Source: promise/lib/method.js, line 30 Returns: Type Promise getHandler() Returns the handler function associated with this method Inherited From: Method#getHandler Source: lib/method.js, line 43 Returns: Type function setHandler(handler) Sets the handler function associated with this method Parameters: Name Type Description handler function Inherited From: Method#setHandler Source: lib/method.js, line 51 × Search results Close "},"PromiseServer.html":{"id":"PromiseServer.html","title":"Class: PromiseServer","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: PromiseServer PromiseServer new PromiseServer() Constructor for a Jayson Promise Server Source: promise/lib/server.js, line 6 See: Server Returns: Type PromiseServer Extends Server Methods _resolveRouter(method, params) Invoke the router Parameters: Name Type Description method String Method to resolve params Array | Object Request params Inherited From: Server#_resolveRouter Source: lib/server/index.js, line 341 Returns: Type Method call(request [, context] [, callback]) Calls a method on the server Parameters: Name Type Argument Description request Object | Array | String A JSON-RPC request object. Object for single request, Array for batches and String for automatic parsing (using the reviver option) context Object &lt;optional&gt; Optional context object passed to methods callback function &lt;optional&gt; Callback that receives one of two arguments: first is an error and the second a response Inherited From: Server#call Source: lib/server/index.js, line 221 error( [code] [, message] [, data]) Returns a JSON-RPC compatible error property Parameters: Name Type Argument Default Description code Number &lt;optional&gt; -32603 Error code message String &lt;optional&gt; &quot;Internal error&quot; Error message data Object &lt;optional&gt; Additional data that should be provided Inherited From: Server#error Source: lib/server/index.js, line 199 Returns: Type Object getMethod(name) Gets a method from the server Parameters: Name Type Description name String Inherited From: Server#getMethod Source: lib/server/index.js, line 188 Returns: Type Method hasMethod(name) Checks if a method is registered with the server Parameters: Name Type Description name String Name of method Inherited From: Server#hasMethod Source: lib/server/index.js, line 169 Returns: Type Boolean method(name, definition) Adds a single method to the server Parameters: Name Type Description name String Name of method to add definition function | Client Function or Client for a relayed method Inherited From: Server#method Source: lib/server/index.js, line 120 Throws: Invalid parameters Type TypeError methods(methods) Adds a batch of methods to the server Parameters: Name Type Description methods Object Methods to add Inherited From: Server#methods Source: lib/server/index.js, line 155 removeMethod(name) Removes a method from the server Parameters: Name Type Description name String Inherited From: Server#removeMethod Source: lib/server/index.js, line 177 × Search results Close "},"PromiseUtils.html":{"id":"PromiseUtils.html","title":"Namespace: PromiseUtils","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: PromiseUtils PromiseUtils Source: promise/lib/utils.js, line 6 Methods &lt;static&gt; wrapClientRequestMethod(request) Wraps the client request method on an instance, making it return a promise in every case except when the fourth argument is explicitly set to false Parameters: Name Type Description request function The original request method Source: promise/lib/utils.js, line 13 Returns: Type function × Search results Close "},"Server.html":{"id":"Server.html","title":"Class: Server","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: Server Server new Server( [methods] [, options]) Constructor for a Jayson Server Parameters: Name Type Argument Description methods Object.&lt;String, function()&gt; &lt;optional&gt; Methods to add options Object &lt;optional&gt; Properties Name Type Argument Default Description params Array | Object &lt;optional&gt; Passed to Jayson.Method as an option when created useContext Boolean &lt;optional&gt; false Passed to Jayson.Method as an option when created reviver function &lt;optional&gt; Reviver function for JSON replacer function &lt;optional&gt; Replacer function for JSON methodConstructor function &lt;optional&gt; Methods will be made instances of this class encoding String &lt;optional&gt; &quot;utf8&quot; Encoding to use version Number &lt;optional&gt; 2 JSON-RPC version to use (1|2) router function &lt;optional&gt; Function to use for routing methods Properties: Name Type Description options Object A reference to the internal options object that can be modified directly errorMessages Object Map of error code to error message pairs that will be used in server responses http ServerHttp HTTP interface constructor https ServerHttps HTTPS interface constructor tcp ServerTcp TCP interface constructor tls ServerTls TLS interface constructor middleware Middleware Middleware generator function Source: lib/server/index.js, line 8 Returns: Type Server Extends require('events').EventEmitter Members &lt;static&gt; errors :Number JSON-RPC specification errors that map to an integer code Type: Number Properties: Name Type Default Description PARSE_ERROR Number -32700 INVALID_REQUEST Number -32600 METHOD_NOT_FOUND Number -32601 INVALID_PARAMS Number -32602 INTERNAL_ERROR Number -32603 Source: lib/server/index.js, line 94 &lt;static&gt; interfaces :function Interfaces that will be automatically bound as properties of a Server instance Type: function Properties: Name Type Default Description http function https function tcp function tls function middleware function Source: lib/server/index.js, line 81 Methods _resolveRouter(method, params) Invoke the router Parameters: Name Type Description method String Method to resolve params Array | Object Request params Source: lib/server/index.js, line 341 Returns: Type Method call(request [, context] [, callback]) Calls a method on the server Parameters: Name Type Argument Description request Object | Array | String A JSON-RPC request object. Object for single request, Array for batches and String for automatic parsing (using the reviver option) context Object &lt;optional&gt; Optional context object passed to methods callback function &lt;optional&gt; Callback that receives one of two arguments: first is an error and the second a response Source: lib/server/index.js, line 221 error( [code] [, message] [, data]) Returns a JSON-RPC compatible error property Parameters: Name Type Argument Default Description code Number &lt;optional&gt; -32603 Error code message String &lt;optional&gt; &quot;Internal error&quot; Error message data Object &lt;optional&gt; Additional data that should be provided Source: lib/server/index.js, line 199 Returns: Type Object getMethod(name) Gets a method from the server Parameters: Name Type Description name String Source: lib/server/index.js, line 188 Returns: Type Method hasMethod(name) Checks if a method is registered with the server Parameters: Name Type Description name String Name of method Source: lib/server/index.js, line 169 Returns: Type Boolean method(name, definition) Adds a single method to the server Parameters: Name Type Description name String Name of method to add definition function | Client Function or Client for a relayed method Source: lib/server/index.js, line 120 Throws: Invalid parameters Type TypeError methods(methods) Adds a batch of methods to the server Parameters: Name Type Description methods Object Methods to add Source: lib/server/index.js, line 155 removeMethod(name) Removes a method from the server Parameters: Name Type Description name String Source: lib/server/index.js, line 177 × Search results Close "},"ServerHttp.html":{"id":"ServerHttp.html","title":"Class: ServerHttp","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerHttp ServerHttp new ServerHttp(server [, options]) Constructor for a Jayson HTTP server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/http.js, line 6 Returns: Type ServerHttp Extends require('http').Server × Search results Close "},"ServerHttps.html":{"id":"ServerHttps.html","title":"Class: ServerHttps","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerHttps ServerHttps new ServerHttps(server [, options]) Constructor for a Jayson HTTPS server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/https.js, line 6 Returns: Type ServerHttps Extends require('https').Server × Search results Close "},"ServerMiddleware.html":{"id":"ServerMiddleware.html","title":"Class: ServerMiddleware","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerMiddleware ServerMiddleware new ServerMiddleware(server [, outerOptions]) Creates a Connect/Express compatible middleware bound to a Server Parameters: Name Type Argument Description server Server Server instance outerOptions Object &lt;optional&gt; Specific options for the middleware Source: lib/server/middleware.js, line 5 Returns: Type function × Search results Close "},"ServerTcp.html":{"id":"ServerTcp.html","title":"Class: ServerTcp","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerTcp ServerTcp new ServerTcp(server [, options]) Constructor for a Jayson TCP server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/tcp.js, line 6 Returns: Type ServerTcp Extends require('net').Server × Search results Close "},"ServerTls.html":{"id":"ServerTls.html","title":"Class: ServerTls","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Class: ServerTls ServerTls new ServerTls(server [, options]) Constructor for a Jayson TLS-encrypted TCP server Parameters: Name Type Argument Description server Server Server instance options Object &lt;optional&gt; Options for this instance Source: lib/server/tls.js, line 6 Returns: Type ServerTls Extends require('tls').Server × Search results Close "},"Utils.html":{"id":"Utils.html","title":"Namespace: Utils","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Utils Utils Source: lib/utils.js, line 10 Namespaces JSON Request Response Methods &lt;static&gt; generateId() Generates a random UUID Source: lib/utils.js, line 49 Returns: Type String &lt;static&gt; parseBody(stream [, reviver], callback) Helper to parse a stream and interpret it as JSON Parameters: Name Type Argument Description stream Stream Stream instance reviver function &lt;optional&gt; Optional reviver for JSON.parse callback function Source: lib/utils.js, line 99 &lt;static&gt; parseStream(stream, options, onRequest) Parses an incoming stream for requests using JSONStream Parameters: Name Type Description stream Stream options Object onRequest function Called once for stream errors and an unlimited amount of times for valid requests Source: lib/utils.js, line 69 &lt;static&gt; response(error, result, id, version) Generates a JSON-RPC 1.0 or 2.0 response Parameters: Name Type Description error Object Error member result Object Result member id String | Number | null Id of request version Number JSON-RPC version to use Source: lib/utils.js, line 25 Returns: A JSON-RPC 1.0 or 2.0 response Type Object &lt;static&gt; walk(holder, key, fn) Recursively walk an object and apply a function on its members Parameters: Name Type Description holder Object The object to walk key String The key to look at fn function The function to apply to members Source: lib/utils.js, line 219 Returns: Type Object × Search results Close "},"Utils.JSON.html":{"id":"Utils.JSON.html","title":"Namespace: JSON","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: JSON Utils. JSON Source: lib/utils.js, line 237 Methods &lt;static&gt; parse(str, options) Parses a JSON string and then invokes the given callback Parameters: Name Type Description str String The string to parse options Object Object with options, possibly holding a &quot;reviver&quot; function Source: lib/utils.js, line 244 &lt;static&gt; stringify(obj, options) Stringifies JSON and then invokes the given callback Parameters: Name Type Description obj Object The object to stringify options Object Object with options, possibly holding a &quot;replacer&quot; function Source: lib/utils.js, line 267 × Search results Close "},"Utils.Request.html":{"id":"Utils.Request.html","title":"Namespace: Request","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Request Utils. Request Source: lib/utils.js, line 286 Methods &lt;static&gt; isBatch(request) Determines if the passed request is a batch request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 293 Returns: Type Boolean &lt;static&gt; isNotification(request) Determines if the passed request is a notification request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 302 Returns: Type Boolean &lt;static&gt; isValidRequest(request [, version]) Determines if the passed request is a valid JSON-RPC Request Parameters: Name Type Argument Default Description request Object The request version Number &lt;optional&gt; 2 JSON-RPC version 1 or 2 Source: lib/utils.js, line 357 Returns: Type Boolean &lt;static&gt; isValidVersionOneRequest(request) Determines if the passed request is a valid JSON-RPC 1.0 Request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 341 Returns: Type Boolean &lt;static&gt; isValidVersionTwoRequest(request) Determines if the passed request is a valid JSON-RPC 2.0 Request Parameters: Name Type Description request Object The request Source: lib/utils.js, line 316 Returns: Type Boolean × Search results Close "},"Utils.Response.html":{"id":"Utils.Response.html","title":"Namespace: Response","body":" Jayson Namespaces JaysonJaysonPromisePromiseUtilsUtilsUtils.JSONUtils.RequestUtils.Response Classes ClientClientBrowserClientHttpClientHttpsClientTcpClientTlsMethodPromiseClientPromiseClientHttpPromiseClientHttpsPromiseClientTcpPromiseClientTlsPromiseMethodPromiseServerServerServerHttpServerHttpsServerMiddlewareServerTcpServerTls Namespace: Response Utils. Response Source: lib/utils.js, line 369 Methods &lt;static&gt; isValidError(error [, version]) Determines if the passed error is a valid JSON-RPC error response Parameters: Name Type Argument Default Description error Object The error version Number &lt;optional&gt; 2 JSON-RPC version 1 or 2 Source: lib/utils.js, line 377 Returns: Type Boolean &lt;static&gt; isValidResponse(response [, version]) Determines if the passed object is a valid JSON-RPC response Parameters: Name Type Argument Default Description response Object The response version Number &lt;optional&gt; 2 JSON-RPC version 1 or 2 Source: lib/utils.js, line 399 Returns: Type Boolean × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
